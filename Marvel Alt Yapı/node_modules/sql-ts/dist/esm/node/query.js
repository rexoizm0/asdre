'use strict';
import assert from 'assert';
import extend from 'lodash/extend';
import sliced from 'sliced';
import { AddColumnNode, AliasNode, AlterNode, CascadeNode, CreateIndexNode, CreateNode, CreateViewNode, DeleteNode, DistinctNode, DistinctOnNode, DropColumnNode, DropIndexNode, DropNode, ForShareNode, ForUpdateNode, FromNode, GroupByNode, HavingNode, IfExistsNode, IfNotExistsNode, IndexesNode, InsertNode, JoinNode, ModifierNode, Node, OnConflictNode, OnDuplicateNode, OrderByNode, OrIgnoreNode, ParameterNode, PrefixUnaryNode, RenameColumnNode, RenameNode, ReplaceNode, RestrictNode, ReturningNode, SelectNode, TableNode, TruncateNode, UpdateNode, valueExpressionMixin, WhereNode } from '.';
import { Column } from '../column';
import { instanceofINodeable } from '../nodeable';
import { Table } from '../table';
// get the first element of an arguments if it is an array, else return arguments as an array
const getArrayOrArgsAsArray = (args) => {
    const first = args[0];
    if (Array.isArray(first)) {
        return first;
    }
    else {
        return sliced(args);
    }
};
export class Query extends Node {
    constructor(table, isSubquery) {
        super(isSubquery ? 'SUBQUERY' : 'QUERY');
        this.nodes = [];
        this.table = table;
        if (table) {
            this.sql = table.sql;
        }
    }
    select(...args) {
        let select;
        if (this._select) {
            select = this._select;
        }
        else {
            select = this._select = new SelectNode();
            this.add(select);
        }
        // allow things like .select(a.star(), [ a.id, a.name ])
        // this will flatten them into a single array
        const flattenedArgs = sliced(args).reduce((cur, next) => {
            if (Array.isArray(next)) {
                return cur.concat(next);
            }
            cur.push(next);
            return cur;
        }, []);
        select.addAll(flattenedArgs);
        // if this is a subquery then add reference to this column
        if (this.type === 'SUBQUERY') {
            for (const node of select.nodes) {
                const name = node.alias || node.property || node.name;
                const col = new Column(node);
                col.name = name;
                col.property = name;
                col.table = this;
                col.star = undefined;
                const subQuery = this;
                if (subQuery[name] === undefined) {
                    subQuery[name] = col;
                }
                subQuery.columns.push(col);
            }
        }
        return this;
    }
    star() {
        assert(this.type === 'SUBQUERY', 'star() can only be used on a subQuery');
        return new Column({
            star: true,
            table: this
        });
    }
    from(...nodes) {
        const sourceNodes = Array.isArray(nodes[0]) ? nodes[0] : nodes;
        for (const node of sourceNodes) {
            this.add(new FromNode().add(node));
        }
        return this;
    }
    leftJoin(other) {
        assert(this.type === 'SUBQUERY', 'leftJoin() can only be used on a subQuery');
        return new JoinNode('LEFT', this, other.toNode());
    }
    where(...nodes) {
        if (nodes.length > 1) {
            // allow multiple where clause arguments
            const args = sliced(nodes);
            for (const arg of args) {
                this.where(arg);
            }
            return this;
        }
        else {
            const node = nodes[0];
            // calling #where twice functions like calling #where & then #and
            if (this.whereClause) {
                return this.and(node);
            }
            this.whereClause = new WhereNode(this.table);
            this.whereClause.add(node);
            return this.add(this.whereClause);
        }
    }
    or(object) {
        if (!this.whereClause) {
            return this.where(object);
        }
        this.whereClause.or(object);
        return this;
    }
    and(node) {
        if (!this.whereClause) {
            return this.where(node);
        }
        this.whereClause.and(node);
        return this;
    }
    order(...nodes) {
        const args = getArrayOrArgsAsArray(nodes);
        let orderBy;
        if (args.length === 0) {
            return this;
        }
        if (this._orderBy) {
            orderBy = this._orderBy;
        }
        else {
            orderBy = this._orderBy = new OrderByNode();
            this.add(orderBy);
        }
        orderBy.addAll(args);
        return this;
    }
    group(...nodes) {
        const args = getArrayOrArgsAsArray(nodes);
        const groupBy = new GroupByNode().addAll(args);
        return this.add(groupBy);
    }
    having(...nodes) {
        const args = getArrayOrArgsAsArray(nodes);
        const having = new HavingNode().addAll(args);
        return this.add(having);
    }
    insert(...nodes) {
        let args = sliced(nodes);
        const object = nodes[0];
        if (Array.isArray(object)) {
            for (const col of object) {
                this.insert(col);
            }
            return this;
        }
        else if (!instanceofINodeable(object) && typeof object === 'object') {
            args = [];
            Object.keys(object).forEach((key) => {
                const col = this.table.get(key);
                if (col && !col.autoGenerated) {
                    args.push(col.value(object[key]));
                }
            });
        }
        if (this.insertClause) {
            this.insertClause.add(args);
            return this;
        }
        else {
            this.insertClause = new InsertNode();
            this.insertClause.add(args);
            return this.add(this.insertClause);
        }
    }
    replace(...nodes) {
        let args = sliced(nodes);
        const object = nodes[0];
        if (Array.isArray(object)) {
            for (const col of object) {
                this.replace(col);
            }
            return this;
        }
        else if (!instanceofINodeable(object) && typeof object === 'object') {
            args = [];
            Object.keys(object).forEach((key) => {
                const col = this.table.get(key);
                if (col && !col.autoGenerated) {
                    args.push(col.value(object[key]));
                }
            });
        }
        if (this.replaceClause) {
            this.replaceClause.add(args);
            return this;
        }
        else {
            this.replaceClause = new ReplaceNode();
            this.replaceClause.add(args);
            return this.add(this.replaceClause);
        }
    }
    update(object) {
        const update = new UpdateNode();
        Object.keys(object).forEach((key) => {
            const col = this.table.get(key);
            if (col && !col.autoGenerated) {
                const val = object[key];
                update.add(col.value(ParameterNode.getNodeOrParameterNode(val)));
            }
        });
        return this.add(update);
    }
    parameter(v) {
        const param = ParameterNode.getNodeOrParameterNode(v);
        param.isExplicit = true;
        return this.add(param);
    }
    delete(params) {
        let result;
        if (params) {
            if (params instanceof Table || Array.isArray(params)) {
                // handle explicit delete queries:
                // e.g. post.delete(post).from(post) -> DELETE post FROM post
                // e.g. post.delete([post, user]).from(post) -> DELETE post, user FROM post
                const newParams = Array.isArray(params) ? params.map((table) => new TableNode(table)) : [new TableNode(params)];
                result = this.add(new DeleteNode().addAll(newParams));
            }
            else {
                // syntax sugar for post.delete().from(post).where(params)
                result = this.add(new DeleteNode()).where(params);
            }
        }
        else {
            result = this.add(new DeleteNode());
        }
        return result;
    }
    returning(...args) {
        const returning = new ReturningNode();
        if (args.length === 0) {
            returning.add('*');
        }
        else {
            returning.addAll(getArrayOrArgsAsArray(args));
        }
        return this.add(returning);
    }
    onDuplicate(object) {
        const onDuplicate = new OnDuplicateNode();
        Object.keys(object).forEach((key) => {
            const col = this.table.get(key);
            let val;
            if (col && !col.autoGenerated) {
                val = object[key];
            }
            onDuplicate.add(col.value(ParameterNode.getNodeOrParameterNode(val)));
        });
        return this.add(onDuplicate);
    }
    onConflict(options) {
        const onConflict = new OnConflictNode(options);
        return this.add(onConflict);
    }
    forUpdate() {
        assert(typeof this._select !== 'undefined', 'FOR UPDATE can be used only in a select statement');
        this.add(new ForUpdateNode());
        return this;
    }
    forShare() {
        assert(typeof this._select !== 'undefined', 'FOR SHARE can be used only in a select statement');
        return this.add(new ForShareNode());
    }
    create(indexName) {
        if (this.indexesClause) {
            const createIndex = new CreateIndexNode(this.table, indexName);
            this.add(createIndex);
            return createIndex;
        }
        else {
            return this.add(new CreateNode(this.table.isTemporary));
        }
    }
    drop() {
        if (this.indexesClause) {
            const args = sliced(arguments);
            const dropIndex = new DropIndexNode(this.table, args);
            this.add(dropIndex);
            return dropIndex;
        }
        else {
            return this.add(new DropNode(this.table));
        }
    }
    truncate() {
        return this.add(new TruncateNode(this.table));
    }
    distinct() {
        return this.add(new DistinctNode());
    }
    distinctOn(...args) {
        let distinctOn;
        if (this._distinctOn) {
            distinctOn = this._distinctOn;
        }
        else {
            const select = this.nodes.filter((node) => node.type === 'SELECT').shift();
            distinctOn = this._distinctOn = new DistinctOnNode();
            select.add(distinctOn);
        }
        // allow things like .distinctOn(a.star(), [ a.id, a.name ])
        // this will flatten them into a single array
        const flattenedArgs = sliced(args).reduce((cur, next) => {
            if (Array.isArray(next)) {
                return cur.concat(next);
            }
            cur.push(next);
            return cur;
        }, []);
        distinctOn.addAll(flattenedArgs);
        return this;
    }
    alter() {
        return this.add(new AlterNode());
    }
    rename(newName) {
        const renameClause = new RenameNode();
        if (typeof newName === 'string') {
            newName = new Column({
                name: newName,
                table: this.table
            });
        }
        renameClause.add(newName.toNode());
        this.nodes[0].add(renameClause);
        return this;
    }
    addColumn(column, dataType) {
        const addClause = new AddColumnNode();
        if (typeof column === 'string') {
            column = new Column({
                name: column,
                table: this.table
            });
        }
        if (dataType) {
            column.dataType = dataType;
        }
        addClause.add(column.toNode());
        this.nodes[0].add(addClause);
        return this;
    }
    dropColumn(column) {
        const dropClause = new DropColumnNode();
        if (typeof column === 'string') {
            column = new Column({
                name: column,
                table: this.table
            });
        }
        dropClause.add(column.toNode());
        this.nodes[0].add(dropClause);
        return this;
    }
    renameColumn(oldColumn, newColumn) {
        const renameClause = new RenameColumnNode();
        if (typeof oldColumn === 'string') {
            oldColumn = new Column({
                name: oldColumn,
                table: this.table
            });
        }
        if (typeof newColumn === 'string') {
            newColumn = new Column({
                name: newColumn,
                table: this.table
            });
        }
        renameClause.add(oldColumn.toNode());
        renameClause.add(newColumn.toNode());
        this.nodes[0].add(renameClause);
        return this;
    }
    limit(count) {
        return this.add(new ModifierNode(this, 'LIMIT', count));
    }
    offset(count) {
        return this.add(new ModifierNode(this, 'OFFSET', count));
    }
    exists() {
        assert(this.type === 'SUBQUERY', 'exists() can only be used on a subQuery');
        return new PrefixUnaryNode({
            left: this,
            operator: 'EXISTS'
        });
    }
    notExists() {
        assert(this.type === 'SUBQUERY', 'notExists() can only be used on a subQuery');
        return new PrefixUnaryNode({
            left: this,
            operator: 'NOT EXISTS'
        });
    }
    ifExists() {
        this.nodes[0].unshift(new IfExistsNode());
        return this;
    }
    ifNotExists() {
        this.nodes[0].unshift(new IfNotExistsNode());
        return this;
    }
    orIgnore() {
        this.nodes[0].unshift(new OrIgnoreNode());
        return this;
    }
    cascade() {
        this.nodes[0].add(new CascadeNode());
        return this;
    }
    restrict() {
        this.nodes[0].add(new RestrictNode());
        return this;
    }
    indexes() {
        this.indexesClause = new IndexesNode(this.table);
        return this.add(this.indexesClause);
    }
    createView(viewName) {
        this.add(new CreateViewNode(viewName));
        return this;
    }
}
// Here we are extending query with valueExpressions so that it's possible to write queries like
//   const query=sql.select(a.select(a.x.sum()).plus(b.select(b.y.sum()))
// which generates:
//   SELECT (SELECT SUM(a.x) FROM a) + (SELECT SUM(b.y) FROM b)
// We need to remove "or" and "and" from here because it conflicts with the already existing functionality of appending
// to the where clause like so:
//   const query=a.select().where(a.name.equals("joe")).or(a.name.equals("sam"))
const valueExpressions = valueExpressionMixin();
// @ts-ignore
delete valueExpressions.or;
// @ts-ignore
delete valueExpressions.and;
extend(Query.prototype, valueExpressions);
// Extend the query with the aliasMixin so that it's possible to write queries like
//   const query=sql.select(a.select(a.count()).as("column1"))
// which generates:
//   SELECT (SELECT COUNT(*) FROM a) AS "column1"
extend(Query.prototype, AliasNode.AliasMixin);
//# sourceMappingURL=query.js.map