'use strict';
import extend from 'lodash/extend';
import { ColumnNode, OrderByValueNode, TextNode, valueExpressionMixin } from './node';
export class Column {
    constructor(config) {
        this.subfields = {};
        this.asArray = false;
        this.name = config.name;
        this.property = config.property;
        this.star = config.star;
        this.table = config.table;
        this.alias = undefined;
        this.isConstant = config.isConstant;
        this.constantValue = config.constantValue;
        this.dataType = config.dataType;
        this.primaryKey = config.primaryKey;
        this.notNull = config.notNull;
        this.defaultValue = config.defaultValue;
        this.references = config.references;
        this.subfieldContainer = config.subfieldContainer;
        this.autoGenerated = config.autoGenerated;
        this.unique = config.unique;
    }
    value(value) {
        const context = contextify(this);
        context._value = value;
        return context;
    }
    getValue() {
        return this._value;
    }
    toNode() {
        // creates a query node from this column
        return new ColumnNode(contextify(this));
    }
    as(alias) {
        const context = contextify(this);
        context.alias = alias;
        return new ColumnNode(context);
    }
    asc() {
        return new OrderByValueNode({
            value: this.toNode()
        });
    }
    desc() {
        return new OrderByValueNode({
            direction: new TextNode('DESC'),
            value: this.toNode()
        });
    }
    arrayAgg(alias) {
        const context = contextify(this);
        context.asArray = true;
        context.alias = alias || context.name + 's';
        return new ColumnNode(context);
    }
    aggregate(alias, aggregator) {
        const context = contextify(this);
        context.aggregator = aggregator.toUpperCase();
        context.alias = alias || context.name + '_' + context.aggregator.toLowerCase();
        return new ColumnNode(context);
    }
    count(alias) {
        return this.aggregate(alias, 'count');
    }
    min(alias) {
        return this.aggregate(alias, 'min');
    }
    max(alias) {
        return this.aggregate(alias, 'max');
    }
    sum(alias) {
        return this.aggregate(alias, 'sum');
    }
    avg(alias) {
        return this.aggregate(alias, 'avg');
    }
    distinct() {
        const context = contextify(this);
        context.isDistinct = true;
        return new ColumnNode(context);
    }
    toQuery() {
        return this.toNode().toQuery();
    }
}
// mix in value expression
extend(Column.prototype, valueExpressionMixin());
const contextify = (base) => {
    const context = Object.create(Column.prototype);
    Object.keys(base).forEach((key) => {
        context[key] = base[key];
    });
    return context;
};
//# sourceMappingURL=column.js.map