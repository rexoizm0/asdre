import { CreateIndexNode, DropIndexNode, IAliasMixin, IValueExpressionMixinBase, JoinNode, Node, PrefixUnaryNode } from '.';
import { Column } from '../column';
import { INodeable, PartialNodeable } from '../nodeable';
import { Table } from '../table';
export declare class Query<T> extends Node {
    table: Table<T>;
    nodes: Node[];
    alias?: string;
    private whereClause?;
    private insertClause?;
    private replaceClause?;
    private indexesClause?;
    private _select?;
    private _orderBy?;
    private _distinctOn?;
    constructor(table: Table<T>, isSubquery?: boolean);
    select(...args: any[]): this;
    star(): Column<unknown>;
    from(node: INodeable[] | INodeable | string): this;
    from(...nodes: INodeable[]): this;
    leftJoin(other: INodeable): JoinNode;
    where(object: Partial<T> | Node[] | Node | string): this;
    where(...nodes: Node[]): this;
    or(object: Partial<T> | Node | string): this;
    and(object: Partial<T> | Node[] | Node | string): this;
    order(node: INodeable[] | INodeable): this;
    order(...nodes: INodeable[]): this;
    group(node: INodeable[] | INodeable): this;
    group(...nodes: INodeable[]): this;
    having(node: INodeable[] | INodeable): this;
    having(...nodes: INodeable[]): this;
    insert(object: Column<unknown>[] | Column<unknown>): this;
    insert(object: PartialNodeable<T>[] | PartialNodeable<T>): this;
    insert(...nodes: Column<unknown>[]): this;
    replace(object: Column<unknown>[] | Column<unknown>): this;
    replace(object: Partial<T>[] | Partial<T>): this;
    replace(...nodes: Column<unknown>[]): this;
    update(object: PartialNodeable<T>): this;
    parameter(v: any): this;
    delete(table: Table<unknown>[] | Table<unknown> | Partial<T>): this;
    delete(): this;
    returning(...args: any[]): this;
    onDuplicate(object: Partial<T>): this;
    onConflict(options: {
        constraint: string;
        update?: string[];
    } | {
        columns: string[];
        update?: string[];
    }): this;
    forUpdate(): this;
    forShare(): this;
    create(): this;
    create(indexName: string): CreateIndexNode;
    drop(): this;
    drop(indexName: string): DropIndexNode;
    drop(...columns: Column<unknown>[]): DropIndexNode;
    truncate(): this;
    distinct(): this;
    distinctOn(...args: any[]): this;
    alter(): this;
    rename(newName: Column<unknown> | string): this;
    addColumn(column: Column<unknown> | string, dataType?: string): this;
    dropColumn(column: Column<unknown> | string): this;
    renameColumn(oldColumn: Column<unknown> | string, newColumn: Column<unknown> | string): this;
    limit(count: unknown): this;
    offset(count: unknown): this;
    exists(): PrefixUnaryNode;
    notExists(): PrefixUnaryNode;
    ifExists(): this;
    ifNotExists(): this;
    orIgnore(): this;
    cascade(): this;
    restrict(): this;
    indexes(): this;
    createView(viewName: string): this;
}
export interface Query<T> extends IValueExpressionMixinBase, IAliasMixin {
}
declare type SubQueryExtensions<T, C extends object> = {
    join: (other: INodeable) => JoinNode;
} & {
    columns: Column<unknown>[];
} & {
    [P in NonNullable<keyof C>]: Column<C[P]>;
};
export declare type SubQuery<T, C extends object> = Query<T> & SubQueryExtensions<T, C>;
export {};
