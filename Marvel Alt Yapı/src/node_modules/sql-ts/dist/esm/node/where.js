'use strict';
import { BinaryNode, Node, TextNode } from '.';
import { instanceofINodeable } from '../nodeable';
const normalizeNode = (table, node) => {
    if (typeof node === 'string') {
        return new TextNode(`(${node})`);
    }
    else if (Array.isArray(node)) {
        if (node.length === 0) {
            return new TextNode('(1 = 1)');
        }
        else {
            let result;
            for (const subNode of node) {
                result = !result ? subNode : result.and(subNode);
            }
            return result;
        }
    }
    else if (!instanceofINodeable(node) && typeof node === 'object') {
        let result;
        for (const colName in node) {
            if (colName in node) {
                const column = table.getColumn(colName);
                const query = column.equals(node[colName]);
                result = !result ? query : result.and(query);
            }
        }
        return result;
    }
    else {
        return node.toNode();
    }
};
export class WhereNode extends Node {
    constructor(table) {
        super('WHERE');
        this.table = table;
    }
    add(node) {
        const add = normalizeNode(this.table, node);
        return super.add(add);
    }
    or(other) {
        const right = normalizeNode(this.table, other);
        // calling 'or' without an initial 'where'
        if (!this.nodes.length) {
            this.add(other);
        }
        else {
            this.nodes.push(new BinaryNode({
                left: this.nodes.pop(),
                operator: 'OR',
                right
            }));
        }
    }
    and(other) {
        const right = normalizeNode(this.table, other);
        this.nodes.push(new BinaryNode({
            left: this.nodes.pop(),
            operator: 'AND',
            right
        }));
    }
}
//# sourceMappingURL=where.js.map