import assert from 'assert';
import defaults from 'lodash/defaults.js';
import flatten from 'lodash/flatten.js';
import sliced from 'sliced';
import map from 'lodash/map.js';
import fromPairs from 'lodash/fromPairs.js';
import reduce from 'lodash/reduce.js';
import isNumber from 'lodash/isNumber.js';
import isFunction from 'lodash/isFunction.js';
import padStart from 'lodash/padStart.js';
import isArray from 'lodash/isArray.js';

const dialects = new Map();
const registerDialect = (dialect, ctor) => {
    dialects.set(dialect, ctor);
};
// given a dialect name, return the class
const getDialect = (dialect) => {
    const foundDialect = dialects.get(dialect.toLowerCase());
    if (foundDialect == null) {
        throw new Error(dialect + ' is unsupported');
    }
    else {
        return foundDialect;
    }
};
// default dialect is postgres
const DEFAULT_DIALECT = 'postgres';

// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function instanceofINodeable(o) {
    return typeof o === 'object' && o !== null && 'toNode' in o;
}

/* eslint-disable max-classes-per-file */
class Node {
    constructor(type) {
        this.type = type;
        this.nodes = [];
    }
    toNode() {
        return this;
    }
    add(node) {
        assert(node, 'Error while trying to add a non-existent node to a query');
        if (!instanceofINodeable(node)) {
            throw new Error('Expected Node or INodeable, got ' + typeof node);
        }
        this.nodes.push(node.toNode());
        return this;
    }
    unshift(node) {
        assert(node, 'Error while trying to add a non-existent node to a query');
        if (!instanceofINodeable(node)) {
            throw new Error('Expected Node or INodeable, got ' + typeof node);
        }
        this.nodes.unshift(node.toNode());
        return this;
    }
    toQuery(dialect) {
        const DialectClass = determineDialect(this, dialect);
        return initializeDialect(DialectClass, this).getQuery(this);
    }
    toNamedQuery(name, dialect) {
        if (!name || typeof name !== 'string' || name === '') {
            throw new Error('A query name has to be a non-empty String.');
        }
        const query = this.toQuery(dialect);
        return Object.assign(Object.assign({}, query), { name });
    }
    toString(dialect) {
        const DialectClass = determineDialect(this, dialect);
        return initializeDialect(DialectClass, this).getString(this);
    }
    addAll(nodes) {
        for (let i = 0, len = nodes.length; i < len; i++) {
            this.add(nodes[i]);
        }
        return this;
    }
}
// Before the change that introduced parallel dialects, every node could be turned
// into a query. The parallel dialects change made it impossible to change some nodes
// into a query because not all nodes are constructed with the sql instance.
const determineDialect = (query, dialect) => {
    const sql = query.sql || (query.table && query.table.sql);
    let DialectClass;
    if (dialect) {
        // dialect is specified
        DialectClass = getDialect(dialect);
    }
    else if (sql && sql.dialect) {
        // dialect is not specified, use the dialect from the sql instance
        DialectClass = sql.dialect;
    }
    else {
        // dialect is not specified, use the default dialect
        DialectClass = getDialect(DEFAULT_DIALECT);
    }
    return DialectClass;
};
const initializeDialect = (DialectClass, query) => {
    const sql = query.sql || (query.table && query.table.sql);
    const config = sql ? sql.config : {};
    return new DialectClass(config);
};

class ParameterNode extends Node {
    constructor(val) {
        super('PARAMETER');
        this.val = val;
        this.isExplicit = false;
    }
    // wrap a value as a parameter node if value is not already a node
    static getNodeOrParameterNode(value) {
        return value && instanceofINodeable(value) ? value.toNode() : new ParameterNode(value);
    }
    value() {
        return this.val;
    }
}

class TextNode extends Node {
    constructor(text) {
        super('TEXT');
        this.text = text;
    }
}

const classMap = new Map();
// Process values, wrapping them in ParameterNode if necessary.
const processParam = (val) => {
    if (Array.isArray(val)) {
        throw new Error('expected single value');
    }
    return ParameterNode.getNodeOrParameterNode(val);
};
const processParams = (val) => {
    if (!Array.isArray(val)) {
        throw new Error('expected array value');
    }
    return val.map(ParameterNode.getNodeOrParameterNode);
};
const processParamOrParams = (val) => {
    return Array.isArray(val) ? val.map(ParameterNode.getNodeOrParameterNode) : ParameterNode.getNodeOrParameterNode(val);
};
// Builder functions
const postfixUnaryMethod = (operator) => {
    return function () {
        const ctor = classMap.get('POSTFIX UNARY');
        return new ctor({
            left: this.toNode(),
            operator
        });
    };
};
const binaryMethod = (operator) => {
    return function (val) {
        const ctor = classMap.get('BINARY');
        return new ctor({
            left: this.toNode(),
            operator,
            right: processParamOrParams(val)
        });
    };
};
const ternaryMethod = (operator, separator) => {
    return function (middle, right) {
        const ctor = classMap.get('TERNARY');
        return new ctor({
            left: this.toNode(),
            operator,
            middle: processParam(middle),
            separator,
            right: processParam(right)
        });
    };
};
const orderMethod = (direction) => {
    return function () {
        const ctor = classMap.get('ORDER BY VALUE');
        return new ctor({
            value: this.toNode(),
            direction: direction ? new TextNode(direction) : undefined
        });
    };
};
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function ValueExpressionBaseMixin(Base) {
    class ValueExpressionBaseClass extends Base {
        constructor() {
            super(...arguments);
            this.isNull = postfixUnaryMethod('IS NULL');
            this.isNotNull = postfixUnaryMethod('IS NOT NULL');
            this.equals = binaryMethod('=');
            this.notEquals = binaryMethod('<>');
            this.gt = binaryMethod('>');
            this.gte = binaryMethod('>=');
            this.lt = binaryMethod('<');
            this.lte = binaryMethod('<=');
            this.plus = binaryMethod('+');
            this.minus = binaryMethod('-');
            this.multiply = binaryMethod('*');
            this.divide = binaryMethod('/');
            this.modulo = binaryMethod('%');
            this.leftShift = binaryMethod('<<');
            this.rightShift = binaryMethod('>>');
            this.bitwiseAnd = binaryMethod('&');
            this.bitwiseNot = binaryMethod('~');
            this.bitwiseOr = binaryMethod('|');
            this.bitwiseXor = binaryMethod('#');
            this.regex = binaryMethod('~');
            this.iregex = binaryMethod('~*');
            this.regexp = binaryMethod('REGEXP');
            this.notRegex = binaryMethod('!~');
            this.notIregex = binaryMethod('!~*');
            this.concat = binaryMethod('||');
            this.key = binaryMethod('->');
            this.keyText = binaryMethod('->>');
            this.path = binaryMethod('#>');
            this.pathText = binaryMethod('#>>');
            this.like = binaryMethod('LIKE');
            this.rlike = binaryMethod('RLIKE');
            this.notLike = binaryMethod('NOT LIKE');
            this.ilike = binaryMethod('ILIKE');
            this.notIlike = binaryMethod('NOT ILIKE');
            this.match = binaryMethod('@@');
            this.between = ternaryMethod('BETWEEN', 'AND');
            this.notBetween = ternaryMethod('NOT BETWEEN', 'AND');
            this.contains = binaryMethod('@>');
            this.containedBy = binaryMethod('<@');
            this.containsKey = binaryMethod('?');
            this.overlap = binaryMethod('&&');
            this.descending = orderMethod('DESC');
        }
        in(val) {
            const ctor = classMap.get('IN');
            return new ctor({
                left: this.toNode(),
                right: processParamOrParams(val)
            });
        }
        notIn(val) {
            const ctor = classMap.get('NOT IN');
            return new ctor({
                left: this.toNode(),
                right: processParamOrParams(val)
            });
        }
        at(index) {
            const ctor = classMap.get('AT');
            return new ctor(this.toNode(), processParam(index));
        }
        slice(start, end) {
            const ctor = classMap.get('SLICE');
            return new ctor(this.toNode(), processParam(start), processParam(end));
        }
        cast(dataType) {
            const ctor = classMap.get('CAST');
            return new ctor(this.toNode(), dataType);
        }
        case(whenList, thenList, elseBranch) {
            const ctor = classMap.get('CASE');
            if (undefined !== elseBranch) {
                elseBranch = processParam(elseBranch);
            }
            return new ctor({
                whenList: processParams(whenList),
                thenList: processParams(thenList),
                else: elseBranch
            });
        }
    }
    return ValueExpressionBaseClass;
}
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function ValueExpressionMixin(Base) {
    class ValueExpressionClass extends ValueExpressionBaseMixin(Base) {
        constructor() {
            super(...arguments);
            this.or = binaryMethod('OR');
            this.and = binaryMethod('AND');
        }
    }
    return ValueExpressionClass;
}
const ValueExpressionBaseNode = ValueExpressionBaseMixin(Node);
const ValueExpressionNode = ValueExpressionMixin(Node);

class AliasNode extends Node {
    constructor(value, alias) {
        super('ALIAS');
        this.value = value;
        this.alias = alias;
    }
}
const AliasMixin = {
    as(alias) {
        // create an alias node
        const aliasNode = new AliasNode(this, alias);
        // defaults the properties of the aliased node
        defaults(aliasNode, this);
        return aliasNode;
    }
};

class AtNode extends ValueExpressionNode {
    constructor(value, index) {
        super('AT');
        this.as = AliasMixin.as;
        this.value = value;
        this.index = index;
    }
}
classMap.set('AT', AtNode);

class BinaryNode extends ValueExpressionNode {
    constructor(config) {
        super('BINARY');
        this.as = AliasMixin.as;
        this.left = config.left;
        this.operator = config.operator;
        this.right = config.right;
    }
}
classMap.set('BINARY', BinaryNode);

class CaseNode extends ValueExpressionNode {
    constructor(config) {
        super('CASE');
        this.as = AliasMixin.as;
        this.whenList = config.whenList;
        this.thenList = config.thenList;
        this.else = config.else;
    }
}
classMap.set('CASE', CaseNode);

class CastNode extends ValueExpressionNode {
    constructor(value, dataType) {
        super('CAST');
        this.as = AliasMixin.as;
        this.value = value;
        this.dataType = dataType;
    }
}
classMap.set('CAST', CastNode);

class InNode extends ValueExpressionNode {
    constructor(config) {
        super('IN');
        this.as = AliasMixin.as;
        this.left = config.left;
        this.right = config.right;
    }
}
classMap.set('IN', InNode);

class NotInNode extends ValueExpressionNode {
    constructor(config) {
        super('NOT IN');
        this.as = AliasMixin.as;
        this.left = config.left;
        this.right = config.right;
    }
}
classMap.set('NOT IN', NotInNode);

class OrderByValueNode extends Node {
    constructor(config) {
        super('ORDER BY VALUE');
        this.value = config.value;
        this.direction = config.direction;
    }
}
classMap.set('ORDER BY VALUE', OrderByValueNode);

class PostfixUnaryNode extends ValueExpressionNode {
    constructor(config) {
        super('POSTFIX UNARY');
        this.as = AliasMixin.as;
        this.left = config.left;
        this.operator = config.operator;
    }
}
classMap.set('POSTFIX UNARY', PostfixUnaryNode);

class SliceNode extends ValueExpressionNode {
    constructor(value, start, end) {
        super('SLICE');
        this.as = AliasMixin.as;
        this.value = value;
        this.start = start;
        this.end = end;
    }
}
classMap.set('SLICE', SliceNode);

class TernaryNode extends ValueExpressionNode {
    constructor(config) {
        super('TERNARY');
        this.as = AliasMixin.as;
        this.left = config.left;
        this.middle = config.middle;
        this.operator = config.operator;
        this.right = config.right;
        this.separator = config.separator;
    }
}
classMap.set('TERNARY', TernaryNode);

class SelectNode extends Node {
    constructor() {
        super('SELECT');
        // used when processing LIMIT clauses in MSSQL
        this.msSQLLimitNode = undefined;
        // set to true when a DISTINCT is used on the entire result set
        this.isDistinct = false;
    }
}

class DefaultNode extends Node {
    constructor() {
        super('DEFAULT');
    }
}

class InsertNode extends Node {
    constructor() {
        super('INSERT');
        this.names = [];
        this.columns = [];
        this.valueSets = [];
    }
    add(nodes) {
        if (!Array.isArray(nodes)) {
            throw new Error('Not an array of column instances');
        }
        let hasColumns = false;
        let hasValues = false;
        const values = {};
        nodes.forEach((node) => {
            const column = node.toNode();
            const name = column.name;
            const idx = this.names.indexOf(name);
            if (idx < 0) {
                this.names.push(name);
                this.columns.push(column);
            }
            hasColumns = true;
            hasValues = hasValues || column.value !== undefined;
            values[name] = column;
        });
        // When none of the columns have a value, it's ambiguous whether the user
        // intends to insert a row of default values or append a SELECT statement
        // later.  Resolve the ambiguity by assuming that if no columns are specified
        // it is a row of default values, otherwise a SELECT will be added.
        if (hasValues || !hasColumns) {
            this.valueSets.push(values);
        }
        return this;
    }
    /*
     * Get parameters for all values to be inserted. This function
     * handles handles bulk inserts, where keys may be present
     * in some objects and not others. When keys are not present,
     * the insert should refer to the column value as DEFAULT.
     */
    getParameters() {
        return this.valueSets.map((nodeDict) => {
            const set = [];
            this.names.forEach((name) => {
                const node = nodeDict[name];
                if (node) {
                    set.push(ParameterNode.getNodeOrParameterNode(node.value));
                }
                else {
                    set.push(new DefaultNode());
                }
            });
            return set;
        });
    }
}

class ReplaceNode extends Node {
    constructor() {
        super('REPLACE');
        this.names = [];
        this.columns = [];
        this.valueSets = [];
    }
    add(nodes) {
        if (!Array.isArray(nodes)) {
            throw new Error('Not an array of column instances');
        }
        let hasColumns = false;
        let hasValues = false;
        const values = {};
        nodes.forEach((node) => {
            const column = node.toNode();
            const name = column.name;
            const idx = this.names.indexOf(name);
            if (idx < 0) {
                this.names.push(name);
                this.columns.push(column);
            }
            hasColumns = true;
            hasValues = hasValues || column.value !== undefined;
            values[name] = column;
        });
        // When none of the columns have a value, it's ambiguous whether the user
        // intends to replace a row of default values or append a SELECT statement
        // later.  Resolve the ambiguity by assuming that if no columns are specified
        // it is a row of default values, otherwise a SELECT will be added.
        if (hasValues || !hasColumns) {
            this.valueSets.push(values);
        }
        return this;
    }
    /*
     * Get parameters for all values to be replaced. This function
     * handles handles bulk replaces, where keys may be present
     * in some objects and not others. When keys are not present,
     * the replace should refer to the column value as DEFAULT.
     */
    getParameters() {
        return this.valueSets.map((nodeDict) => {
            const set = [];
            this.names.forEach((name) => {
                const node = nodeDict[name];
                if (node) {
                    set.push(ParameterNode.getNodeOrParameterNode(node.value));
                }
                else {
                    set.push(new DefaultNode());
                }
            });
            return set;
        });
    }
}

class UpdateNode extends Node {
    constructor() {
        super('UPDATE');
    }
}

class DeleteNode extends Node {
    constructor() {
        super('DELETE');
    }
}

class CreateNode extends Node {
    constructor(isTemporary) {
        super('CREATE');
        this.options = { isTemporary };
    }
}

class DropNode extends Node {
    constructor(table) {
        super('DROP');
        this.add(table);
    }
}

class TruncateNode extends Node {
    constructor(table) {
        super('TRUNCATE');
        this.add(table);
    }
}

class DistinctNode extends Node {
    constructor() {
        super('DISTINCT');
    }
}

class DistinctOnNode extends Node {
    constructor() {
        super('DISTINCT ON');
    }
}

class AlterNode extends Node {
    constructor() {
        super('ALTER');
    }
}

class FromNode extends Node {
    constructor() {
        super('FROM');
        this.skipFromStatement = false;
    }
}

const normalizeNode = (table, node) => {
    if (typeof node === 'string') {
        return new TextNode(`(${node})`);
    }
    else if (Array.isArray(node)) {
        if (node.length === 0) {
            return new TextNode('(1 = 1)');
        }
        else {
            let result;
            for (const subNode of node) {
                result = !result ? subNode : result.and(subNode);
            }
            return result;
        }
    }
    else if (!instanceofINodeable(node) && typeof node === 'object') {
        let result;
        for (const colName in node) {
            if (colName in node) {
                const column = table.getColumn(colName);
                const query = column.equals(node[colName]);
                result = !result ? query : result.and(query);
            }
        }
        return result;
    }
    else {
        return node.toNode();
    }
};
class WhereNode extends Node {
    constructor(table) {
        super('WHERE');
        this.table = table;
    }
    add(node) {
        const add = normalizeNode(this.table, node);
        return super.add(add);
    }
    or(other) {
        const right = normalizeNode(this.table, other);
        // calling 'or' without an initial 'where'
        if (!this.nodes.length) {
            this.add(other);
        }
        else {
            this.nodes.push(new BinaryNode({
                left: this.nodes.pop(),
                operator: 'OR',
                right
            }));
        }
    }
    and(other) {
        const right = normalizeNode(this.table, other);
        this.nodes.push(new BinaryNode({
            left: this.nodes.pop(),
            operator: 'AND',
            right
        }));
    }
}

class OrderByNode extends Node {
    constructor() {
        super('ORDER BY');
        // used when processing OFFSET and LIMIT clauses in MSSQL
        this.msSQLOffsetNode = undefined;
        this.msSQLLimitNode = undefined;
    }
}

class GroupByNode extends Node {
    constructor() {
        super('GROUP BY');
    }
}

class HavingNode extends Node {
    constructor() {
        super('HAVING');
    }
}

class PrefixUnaryNode extends ValueExpressionNode {
    constructor(config) {
        super('PREFIX UNARY');
        this.as = AliasMixin.as;
        this.left = config.left;
        this.operator = config.operator;
    }
}

class TableNode extends Node {
    constructor(table) {
        super('TABLE');
        this.table = table;
    }
}

class ColumnNode extends Node {
    constructor(config) {
        super('COLUMN');
        this.name = config.name;
        this.property = config.property || config.name;
        this.alias = config.alias;
        this.star = config.star;
        this.isConstant = config.isConstant;
        this.constantValue = config.constantValue;
        this.asArray = config.asArray;
        this.aggregator = config.aggregator;
        this.table = config.table;
        this.value = config.getValue();
        this.dataType = config.dataType;
        this.isDistinct = config.isDistinct;
        this.primaryKey = config.primaryKey;
        this.notNull = config.notNull;
        this.defaultValue = config.defaultValue;
        this.references = config.references;
        // If subfieldContainer is present, this is a subfield and subfieldContainer
        // is the parent Column
        this.subfieldContainer = config.subfieldContainer;
        this.subfields = config.subfields;
        this.autoGenerated = !!config.autoGenerated;
        this.unique = !!config.unique;
    }
    distinct() {
        this.isDistinct = true;
        return this;
    }
    as(alias) {
        this.alias = alias;
        return this;
    }
}

class ForeignKeyNode extends Node {
    constructor(config) {
        super('FOREIGN KEY');
        this.name = config.name;
        this.columns = config.columns;
        this.schema = config.schema;
        this.table = config.table;
        this.refColumns = config.refColumns;
        this.onUpdate = config.onUpdate;
        this.onDelete = config.onDelete;
        this.constraint = config.constraint;
    }
}

class FunctionCallNode extends ValueExpressionNode {
    constructor(name, args) {
        super('FUNCTION CALL');
        this.as = AliasMixin.as;
        this.name = name;
        this.addAll(args.map(ParameterNode.getNodeOrParameterNode));
    }
}

class ArrayCallNode extends ValueExpressionNode {
    constructor(args) {
        super('ARRAY CALL');
        this.as = AliasMixin.as;
        args = flatten(args);
        this.addAll(args.map(ParameterNode.getNodeOrParameterNode));
    }
}

class RowCallNode extends ValueExpressionNode {
    constructor(args) {
        super('ROW CALL');
        this.as = AliasMixin.as;
        args = flatten(args);
        this.addAll(args.map(ParameterNode.getNodeOrParameterNode));
    }
}

class AddColumnNode extends Node {
    constructor() {
        super('ADD COLUMN');
    }
}

class DropColumnNode extends Node {
    constructor() {
        super('DROP COLUMN');
    }
}

class RenameColumnNode extends Node {
    constructor() {
        super('RENAME COLUMN');
    }
}

class RenameNode extends Node {
    constructor() {
        super('RENAME');
    }
}

class IfExistsNode extends Node {
    constructor() {
        super('IF EXISTS');
    }
}

class IfNotExistsNode extends Node {
    constructor() {
        super('IF NOT EXISTS');
    }
}

class OrIgnoreNode extends Node {
    constructor() {
        super('OR IGNORE');
    }
}

class CascadeNode extends Node {
    constructor() {
        super('CASCADE');
    }
}

class RestrictNode extends Node {
    constructor() {
        super('RESTRICT');
    }
}

class ForUpdateNode extends Node {
    constructor() {
        super('FOR UPDATE');
    }
}

class ForShareNode extends Node {
    constructor() {
        super('FOR SHARE');
    }
}

// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function hasTable(o) {
    return typeof o === 'object' && o !== null && 'table' in o;
}

class JoinNode extends Node {
    constructor(subType, from, to) {
        super('JOIN');
        this.sql = (hasTable(from) && from.table.sql) || (hasTable(to) && to.table.sql) || undefined;
        this.subType = subType;
        this.from = from.toNode();
        this.to = to.toNode();
    }
    on(node) {
        this.onNode = node;
        return this;
    }
    join(other) {
        return new JoinNode('INNER', this, other);
    }
    leftJoin(other) {
        return new JoinNode('LEFT', this, other);
    }
}

class LiteralNode extends Node {
    constructor(literal) {
        super('LITERAL');
        this.literal = literal;
        this.alias = undefined;
    }
    as(alias) {
        this.alias = alias;
        return this;
    }
}

class ReturningNode extends Node {
    constructor() {
        super('RETURNING');
    }
}

class OnDuplicateNode extends Node {
    constructor() {
        super('ONDUPLICATE');
    }
}

class OnConflictNode extends Node {
    constructor(config) {
        super('ONCONFLICT');
        this.columns = config.columns;
        this.constraint = config.constraint;
        this.update = config.update;
    }
}

class IndexesNode extends Node {
    constructor(table) {
        super('INDEXES');
        this.table = table;
    }
}

class CreateIndexNode extends Node {
    constructor(table, indexName) {
        super('CREATE INDEX');
        this.table = table;
        this.options = { indexName, columns: [] };
    }
    unique() {
        this.options.type = 'unique';
        return this;
    }
    spatial() {
        this.options.type = 'spatial';
        return this;
    }
    fulltext() {
        this.options.type = 'fulltext';
        return this;
    }
    using(algorithm) {
        this.options.algorithm = algorithm;
        return this;
    }
    on(...columns) {
        const args = sliced(columns);
        this.options.columns = this.options.columns.concat(args);
        return this;
    }
    withParser(parser) {
        this.options.parser = parser;
        return this;
    }
    indexName() {
        let result = this.options.indexName;
        if (!result) {
            const columns = this.options.columns.map((col) => (col.name ? col.name : col.value.name)).sort();
            result = [this.table.getName(), ...columns].join('_');
        }
        return result;
    }
    ifNotExists() {
        this.options.ifNotExists = true;
        return this;
    }
}

class DropIndexNode extends Node {
    constructor(table, indexName) {
        super('DROP INDEX');
        if (!indexName) {
            throw new Error('No index defined!');
        }
        else if (Array.isArray(indexName) && typeof indexName[0] === 'string') {
            indexName = indexName[0];
        }
        else if (Array.isArray(indexName)) {
            const columns = indexName.map((col) => col.name).sort();
            indexName = [table.getName()].concat(columns).join('_');
        }
        this.table = table;
        this.options = { indexName };
    }
    ifExists() {
        this.options.ifExists = true;
        return this;
    }
}

class CreateViewNode extends Node {
    constructor(viewName) {
        super('CREATE VIEW');
        this.options = { viewName };
    }
}

class IntervalNode extends Node {
    constructor(args) {
        super('INTERVAL');
        const interval = args[0] || {};
        this.years = interval.years;
        this.months = interval.months;
        this.days = interval.days;
        this.hours = interval.hours;
        this.minutes = interval.minutes;
        this.seconds = interval.seconds;
    }
}

class ModifierNode extends Node {
    constructor(query, type, count) {
        super(type);
        this.query = query;
        this.count = ParameterNode.getNodeOrParameterNode(count);
    }
}

/* eslint-disable max-classes-per-file */
class ColumnBase {
}
class Column extends ValueExpressionMixin(ColumnBase) {
    constructor(config) {
        super();
        this.subfields = {};
        this.asArray = false;
        this.name = config.name;
        this.property = config.property;
        this.star = config.star;
        this.table = config.table;
        this.alias = undefined;
        this.isConstant = config.isConstant;
        this.constantValue = config.constantValue;
        this.dataType = config.dataType;
        this.primaryKey = config.primaryKey;
        this.notNull = config.notNull;
        this.defaultValue = config.defaultValue;
        this.references = config.references;
        this.subfieldContainer = config.subfieldContainer;
        this.autoGenerated = config.autoGenerated;
        this.unique = config.unique;
    }
    value(value) {
        const context = contextify(this);
        context._value = value;
        return context;
    }
    getValue() {
        return this._value;
    }
    toNode() {
        // creates a query node from this column
        return new ColumnNode(contextify(this));
    }
    as(alias) {
        const context = contextify(this);
        context.alias = alias;
        return new ColumnNode(context);
    }
    asc() {
        return new OrderByValueNode({
            value: this.toNode()
        });
    }
    desc() {
        return new OrderByValueNode({
            direction: new TextNode('DESC'),
            value: this.toNode()
        });
    }
    arrayAgg(alias) {
        const context = contextify(this);
        context.asArray = true;
        context.alias = alias || context.name + 's';
        return new ColumnNode(context);
    }
    aggregate(alias, aggregator) {
        const context = contextify(this);
        context.aggregator = aggregator.toUpperCase();
        context.alias = alias || context.name + '_' + context.aggregator.toLowerCase();
        return new ColumnNode(context);
    }
    count(alias) {
        return this.aggregate(alias, 'count');
    }
    min(alias) {
        return this.aggregate(alias, 'min');
    }
    max(alias) {
        return this.aggregate(alias, 'max');
    }
    sum(alias) {
        return this.aggregate(alias, 'sum');
    }
    avg(alias) {
        return this.aggregate(alias, 'avg');
    }
    distinct() {
        const context = contextify(this);
        context.isDistinct = true;
        return new ColumnNode(context);
    }
    toQuery() {
        return this.toNode().toQuery();
    }
}
const contextify = (base) => {
    const context = Object.create(Column.prototype);
    Object.keys(base).forEach((key) => {
        context[key] = base[key];
    });
    return context;
};

const getPrimaryKeyColumn = (table) => {
    for (const col of table.columns) {
        if (col.primaryKey) {
            return col;
        }
    }
    return;
};
const findReference = (left, right) => {
    // find reference
    for (const col of right.columns) {
        const references = col.references;
        if (references) {
            const leftName = left.getName();
            if (typeof references === 'string') {
                if (references === leftName) {
                    const leftCol = getPrimaryKeyColumn(left);
                    return {
                        left: leftCol,
                        right: col
                    };
                }
            }
            else if (references.table === leftName) {
                const leftCol = references.column ? left[references.column] : getPrimaryKeyColumn(left);
                return {
                    left: leftCol,
                    right: col
                };
            }
        }
    }
    return;
};
// auto-join two tables based on column properties
// requires one column to have { references: {table: 'foreignTableName', column: 'foreignColumnName'}}
// or to have { references: 'foreignTableName'} -- in which case the foreign table's primary key is assumed
const leftJoin = (left, right) => {
    let ref = findReference(left, right);
    if (!ref) {
        ref = findReference(right, left);
    }
    return left.join(right).on(ref.left.equals(ref.right));
};

// create a function that creates a function call of the specific name, using the specified sql instance
const getFunctionCallCreator = (name) => {
    return (...args) => {
        // turn array-like arguments object into a true array
        return new FunctionCallNode(name, sliced(args));
    };
};
// creates a hash of functions for a sql instance
const getFunctions = (functionNames) => {
    if (typeof functionNames === 'string') {
        return getFunctionCallCreator(functionNames);
    }
    const functions = reduce(functionNames, (reducer, name) => {
        reducer[name] = getFunctionCallCreator(name);
        return reducer;
    }, {});
    return functions;
};
// aggregate functions available to all databases
const aggregateFunctions = ['AVG', 'COUNT', 'DISTINCT', 'MAX', 'MIN', 'SUM'];
// common scalar functions available to most databases
const scalarFunctions = [
    'ABS',
    'COALESCE',
    'LEFT',
    'LENGTH',
    'LOWER',
    'LTRIM',
    'RANDOM',
    'RIGHT',
    'ROUND',
    'RTRIM',
    'SUBSTR',
    'TRIM',
    'UPPER'
];
const dateFunctions = ['YEAR', 'MONTH', 'DAY', 'HOUR', 'CURRENT_TIMESTAMP'];
// hstore function available to Postgres
const hstoreFunctions = ['HSTORE'];
// text search functions available to Postgres
const textsearchFunctions = ['TS_RANK', 'TS_RANK_CD', 'PLAINTO_TSQUERY', 'TO_TSQUERY', 'TO_TSVECTOR', 'SETWEIGHT'];
// jsonb functions available to postgres
const jsonbFunctions = [
    'JSONB_ARRAY_LENGTH',
    'JSONB_BUILD_ARRAY',
    'JSONB_BUILD_OBECT',
    'JSONB_EXTRACT_PATH',
    'JSONB_INSERT',
    'JSONB_OBJECT',
    'JSONB_PRETTY',
    'JSONB_SET',
    'JSONB_STRIP_NULLS',
    'JSONB_TYPEOF',
    'TO_JSONB',
    'JSONB_ARRAY_ELEMENTS',
    'JSONB_ARRAY_ELEMENTS_TEXT',
    'JSONB_EACH',
    'JSONB_EACH_TEXT',
    'JSONB_OBJECT_KEYS',
    'JSONB_AGG'
];
const standardFunctionNames = [
    ...aggregateFunctions,
    ...scalarFunctions,
    ...hstoreFunctions,
    ...textsearchFunctions,
    ...dateFunctions,
    ...jsonbFunctions
];
// creates a hash of standard functions for a sql instance
const getStandardFunctions = () => {
    return getFunctions(standardFunctionNames);
};

class Sql {
    constructor(dialect = DEFAULT_DIALECT, config = {}) {
        this.setDialect(dialect, config);
        // attach the standard SQL functions to this instance
        this.functions = getStandardFunctions();
        this._function = getFunctions;
    }
    function(...args) {
        return this._function(...args);
    }
    // Define a table
    define(def) {
        def = defaults(def || {}, {
            sql: this
        });
        return Table.define(def);
    }
    defineColumn(def) {
        return new Column(def);
    }
    // Returns a bracketed call creator literal
    array(...args) {
        const arrayCall = new ArrayCallNode(sliced(args));
        return arrayCall;
    }
    // Returns a bracketed call creator literal
    row(...args) {
        const rowCall = new RowCallNode(sliced(args));
        return rowCall;
    }
    // Returns a select statement
    select(...args) {
        const query = new Query({ sql: this });
        query.select(...args);
        return query;
    }
    // Returns an interval clause
    interval(...args) {
        const interval = new IntervalNode(sliced(args));
        return interval;
    }
    // Set the dialect
    setDialect(dialect, config = {}) {
        this.dialect = getDialect(dialect);
        this.dialectName = dialect;
        this.config = config;
        return this;
    }
    // Create a constant Column (for use in SELECT)
    constant(value) {
        const config = {
            constantValue: value,
            isConstant: true,
            name: 'constant',
            property: 'constant'
        };
        const cn = new Column(config);
        return cn;
    }
    // Create a literal
    literal(literal) {
        return new LiteralNode(literal);
    }
    // Create a parameter
    parameter(value) {
        return new ParameterNode(value);
    }
}

class Table {
    constructor(config) {
        this.schema = config.schema;
        this.tableName = config.name;
        this.initialConfig = config;
        this.columnWhiteList = !!config.columnWhiteList;
        this.isTemporary = !!config.isTemporary;
        this.snakeToCamel = !!config.snakeToCamel;
        this.columns = [];
        this.foreignKeys = [];
        this.table = this;
        if (!config.sql) {
            config.sql = new Sql();
        }
        this.sql = config.sql;
        this.engine = config.engine;
        this.charset = config.charset;
    }
    get nodes() {
        return this.select(this.star()).nodes;
    }
    static define(config) {
        const table = new Table(config);
        // allow hash of columns as well as array
        if (config.columns && !Array.isArray(config.columns)) {
            const cols = [];
            for (const key in config.columns) {
                if (config.columns.hasOwnProperty(key)) {
                    const col = config.columns[key];
                    col.name = key;
                    cols.push(col);
                }
            }
            config.columns = cols;
        }
        for (const col of config.columns) {
            table.addColumn(col);
        }
        if (config.foreignKeys !== undefined) {
            if (Array.isArray(config.foreignKeys)) {
                for (const key of config.foreignKeys) {
                    table.foreignKeys.push(new ForeignKeyNode(key));
                }
            }
            else {
                table.foreignKeys.push(new ForeignKeyNode(config.foreignKeys));
            }
        }
        return table;
    }
    clone(config) {
        return Table.define(Object.assign({ columnWhiteList: !!this.columnWhiteList, columns: this.columns, foreignKeys: this.foreignKeys, name: this.tableName, schema: this.schema, snakeToCamel: !!this.snakeToCamel, sql: this.sql }, (config || {})));
    }
    createColumn(col) {
        if (!(col instanceof Column)) {
            if (typeof col === 'string') {
                col = { name: col };
            }
            const column = new Column(Object.assign(Object.assign({}, col), { table: this }));
            // Load subfields from array into an object of form name: Column
            if (Array.isArray(col.subfields)) {
                column.subfields = fromPairs(map(col.subfields, (subfield) => {
                    return [
                        subfield,
                        new Column({
                            name: subfield,
                            subfieldContainer: column,
                            table: this
                        })
                    ];
                }));
            }
            return column;
        }
        return col;
    }
    addColumn(col, options) {
        const column = this.createColumn(col);
        options = Object.assign({ noisy: true }, options);
        if (this.hasColumn(column)) {
            if (options.noisy) {
                throw new Error(`Table ${this.tableName} already has column or property by the name of ${column.name}`);
            }
            else {
                return this;
            }
        }
        else if (!!this[column.name] && process.env.NODE_ENV === 'debug') {
            // eslint-disable-next-line no-console
            console.log(`Please notice that you have just defined the column "${column.name}". In order to access it, you need to use "table.getColumn('${column.name}');"!`);
        }
        this.columns.push(column);
        const snakeToCamel = (snakeName) => {
            return snakeName.replace(/[\-_]([a-z])/g, (m, $1) => $1.toUpperCase());
        };
        const property = (column.property = column.property || (this.snakeToCamel ? snakeToCamel(column.name) : column.name));
        this[property] = this[property] || column;
        return this;
    }
    hasColumn(col) {
        const columnName = col instanceof Column ? col.name : col;
        return this.columns.some((column) => column.property === columnName || column.name === columnName);
    }
    getColumn(colName) {
        for (const col of this.columns) {
            if (colName === col.property || colName === col.name) {
                return col;
            }
        }
        if (this.columnWhiteList) {
            return null;
        }
        throw new Error(`Table ${this.tableName} does not have a column or property named ${colName}`);
    }
    get(colName) {
        return this.getColumn(colName);
    }
    getSchema() {
        return this.schema;
    }
    setSchema(schema) {
        this.schema = schema;
    }
    getName() {
        if (this.sql && this.sql.dialectName === 'mssql' && this.isTemporary) {
            return `#${this.tableName}`;
        }
        return this.tableName;
    }
    star(options) {
        options = options || {};
        if ('prefix' in options) {
            return this.columns.map((column) => column.as(options.prefix + column.name));
        }
        return new Column({ table: this, star: true });
    }
    count(alias) {
        const name = this.alias || this.tableName;
        const col = new Column({ table: this, star: true });
        // ColumnNode
        return col.count(alias || name + '_count');
    }
    select(...args) {
        // create the query and pass it off
        const query = new Query(this);
        if (args.length === 0) {
            query.select(this.star());
        }
        else {
            query.select(...args);
        }
        return query;
    }
    subQuery(alias) {
        // create the query and pass it off
        const query = new Query(this, true);
        query.columns = [];
        query.alias = alias;
        query.join = function (other) {
            return new JoinNode('INNER', this.toNode(), other.toNode());
        };
        return query;
    }
    insert(...nodes) {
        const query = new Query(this);
        if (!nodes[0] || (Array.isArray(nodes[0]) && nodes[0].length === 0)) {
            query.select(this.star());
            query.where('1=2');
        }
        else {
            query.insert(...nodes);
        }
        return query;
    }
    replace(...nodes) {
        const query = new Query(this);
        if (!nodes[0] || (Array.isArray(nodes[0]) && nodes[0].length === 0)) {
            query.select(this.star());
            query.where('1=2');
        }
        else {
            query.replace(...nodes);
        }
        return query;
    }
    toNode() {
        return new TableNode(this);
    }
    join(other) {
        return new JoinNode('INNER', this.toNode(), other.toNode());
    }
    leftJoin(other) {
        return new JoinNode('LEFT', this.toNode(), other.toNode());
    }
    // auto-join tables based on column intropsection
    joinTo(other) {
        return leftJoin(this, other);
    }
    as(alias) {
        // TODO could this be cleaner?
        const t = Table.define(this.initialConfig);
        t.alias = alias;
        return t;
    }
    and(...args) {
        const query = new Query(this);
        query.where(...args);
        return query;
    }
    indexes() {
        return new Query(this).indexes();
    }
    alter() {
        const query = new Query(this);
        query.alter();
        return query;
    }
    create() {
        const query = new Query(this);
        query.create();
        return query;
    }
    delete(arg) {
        const query = new Query(this);
        query.delete(arg);
        return query;
    }
    drop() {
        const query = new Query(this);
        query.drop();
        return query;
    }
    from(...args) {
        const query = new Query(this);
        query.from(...args);
        return query;
    }
    limit(count) {
        const query = new Query(this);
        query.limit(count);
        return query;
    }
    offset(count) {
        const query = new Query(this);
        query.offset(count);
        return query;
    }
    or(object) {
        const query = new Query(this);
        query.or(object);
        return query;
    }
    order(...args) {
        const query = new Query(this);
        query.order(...args);
        return query;
    }
    truncate() {
        const query = new Query(this);
        query.truncate();
        return query;
    }
    update(object) {
        const query = new Query(this);
        query.update(object);
        return query;
    }
    where(...args) {
        const query = new Query(this);
        query.where(...args);
        return query;
    }
}

/* eslint-disable no-underscore-dangle */
// get the first element of an arguments if it is an array, else return arguments as an array
const getArrayOrArgsAsArray = (args) => {
    const first = args[0];
    return Array.isArray(first) ? first : sliced(args);
};
const nodeableOrTextNode = (val) => {
    return instanceofINodeable(val) ? val.toNode() : new TextNode(val);
};
// Here we are extending query from ValueExpressionBaseNode so that it's possible to write queries like
//   const query=sql.select(a.select(a.x.sum()).plus(b.select(b.y.sum()))
// which generates:
//   SELECT (SELECT SUM(a.x) FROM a) + (SELECT SUM(b.y) FROM b)
class Query extends ValueExpressionBaseNode {
    constructor(table, isSubquery) {
        super(isSubquery ? 'SUBQUERY' : 'QUERY');
        this.nodes = [];
        // Extend the query with the aliasMixin so that it's possible to write queries like
        //   const query=sql.select(a.select(a.count()).as("column1"))
        // which generates:
        //   SELECT (SELECT COUNT(*) FROM a) AS "column1"
        this.as = AliasMixin.as;
        this.table = table;
        if (table) {
            this.sql = table.sql;
        }
    }
    select(...args) {
        let select;
        if (this._select) {
            select = this._select;
        }
        else {
            select = this._select = new SelectNode();
            this.add(select);
        }
        // allow things like .select(a.star(), [ a.id, a.name ])
        // this will flatten them into a single array
        const flattenedArgs = sliced(args).reduce((cur, next) => {
            if (Array.isArray(next)) {
                return cur.concat(next);
            }
            cur.push(next);
            return cur;
        }, []);
        select.addAll(flattenedArgs.map(nodeableOrTextNode));
        // if this is a subquery then add reference to this column
        if (this.type === 'SUBQUERY') {
            for (const node of select.nodes) {
                const name = node.alias || node.property || node.name;
                const col = new Column(node);
                col.name = name;
                col.property = name;
                col.table = this;
                col.star = undefined;
                const subQuery = this;
                if (subQuery[name] === undefined) {
                    subQuery[name] = col;
                }
                subQuery.columns.push(col);
            }
        }
        return this;
    }
    star() {
        assert(this.type === 'SUBQUERY', 'star() can only be used on a subQuery');
        return new Column({
            star: true,
            table: this
        });
    }
    from(...nodes) {
        const sourceNodes = Array.isArray(nodes[0]) ? nodes[0] : nodes;
        for (const node of sourceNodes) {
            this.add(new FromNode().add(nodeableOrTextNode(node)));
        }
        return this;
    }
    leftJoin(other) {
        assert(this.type === 'SUBQUERY', 'leftJoin() can only be used on a subQuery');
        return new JoinNode('LEFT', this, other.toNode());
    }
    where(...nodes) {
        if (nodes.length > 1) {
            // allow multiple where clause arguments
            const args = sliced(nodes);
            for (const arg of args) {
                this.where(arg);
            }
            return this;
        }
        else {
            const node = nodes[0];
            // calling #where twice functions like calling #where & then #and
            if (this.whereClause) {
                return this.and(node);
            }
            this.whereClause = new WhereNode(this.table);
            this.whereClause.add(node);
            return this.add(this.whereClause);
        }
    }
    or(object) {
        if (!this.whereClause) {
            return this.where(object);
        }
        this.whereClause.or(object);
        return this;
    }
    and(node) {
        if (!this.whereClause) {
            return this.where(node);
        }
        this.whereClause.and(node);
        return this;
    }
    order(...nodes) {
        const args = getArrayOrArgsAsArray(nodes);
        let orderBy;
        if (args.length === 0) {
            return this;
        }
        if (this._orderBy) {
            orderBy = this._orderBy;
        }
        else {
            orderBy = this._orderBy = new OrderByNode();
            this.add(orderBy);
        }
        orderBy.addAll(args);
        return this;
    }
    group(...nodes) {
        const args = getArrayOrArgsAsArray(nodes);
        const groupBy = new GroupByNode().addAll(args);
        return this.add(groupBy);
    }
    having(...nodes) {
        const args = getArrayOrArgsAsArray(nodes);
        const having = new HavingNode().addAll(args);
        return this.add(having);
    }
    insert(...nodes) {
        let args = sliced(nodes);
        const object = nodes[0];
        if (Array.isArray(object)) {
            for (const col of object) {
                this.insert(col);
            }
            return this;
        }
        else if (!instanceofINodeable(object) && typeof object === 'object') {
            args = [];
            Object.keys(object).forEach((key) => {
                const col = this.table.get(key);
                if (col && !col.autoGenerated) {
                    args.push(col.value(object[key]));
                }
            });
        }
        if (this.insertClause) {
            this.insertClause.add(args);
            return this;
        }
        else {
            this.insertClause = new InsertNode();
            this.insertClause.add(args);
            return this.add(this.insertClause);
        }
    }
    replace(...nodes) {
        let args = sliced(nodes);
        const object = nodes[0];
        if (Array.isArray(object)) {
            for (const col of object) {
                this.replace(col);
            }
            return this;
        }
        else if (!instanceofINodeable(object) && typeof object === 'object') {
            args = [];
            Object.keys(object).forEach((key) => {
                const col = this.table.get(key);
                if (col && !col.autoGenerated) {
                    args.push(col.value(object[key]));
                }
            });
        }
        if (this.replaceClause) {
            this.replaceClause.add(args);
            return this;
        }
        else {
            this.replaceClause = new ReplaceNode();
            this.replaceClause.add(args);
            return this.add(this.replaceClause);
        }
    }
    update(object) {
        const update = new UpdateNode();
        Object.keys(object).forEach((key) => {
            const col = this.table.get(key);
            if (col && !col.autoGenerated) {
                const val = object[key];
                update.add(col.value(ParameterNode.getNodeOrParameterNode(val)));
            }
        });
        return this.add(update);
    }
    parameter(v) {
        const param = ParameterNode.getNodeOrParameterNode(v);
        param.isExplicit = true;
        return this.add(param);
    }
    delete(params) {
        let result;
        if (params) {
            if (params instanceof Table || Array.isArray(params)) {
                // handle explicit delete queries:
                // e.g. post.delete(post).from(post) -> DELETE post FROM post
                // e.g. post.delete([post, user]).from(post) -> DELETE post, user FROM post
                const newParams = Array.isArray(params) ? params.map((table) => new TableNode(table)) : [new TableNode(params)];
                result = this.add(new DeleteNode().addAll(newParams));
            }
            else {
                // syntax sugar for post.delete().from(post).where(params)
                result = this.add(new DeleteNode()).where(params);
            }
        }
        else {
            result = this.add(new DeleteNode());
        }
        return result;
    }
    returning(...args) {
        const returning = new ReturningNode();
        if (args.length === 0) {
            returning.add(new TextNode('*'));
        }
        else {
            returning.addAll(getArrayOrArgsAsArray(args).map(nodeableOrTextNode));
        }
        return this.add(returning);
    }
    onDuplicate(object) {
        const onDuplicate = new OnDuplicateNode();
        Object.keys(object).forEach((key) => {
            const col = this.table.get(key);
            let val;
            if (col && !col.autoGenerated) {
                val = object[key];
            }
            onDuplicate.add(col.value(ParameterNode.getNodeOrParameterNode(val)));
        });
        return this.add(onDuplicate);
    }
    onConflict(options) {
        const onConflict = new OnConflictNode(options);
        return this.add(onConflict);
    }
    forUpdate() {
        assert(typeof this._select !== 'undefined', 'FOR UPDATE can be used only in a select statement');
        this.add(new ForUpdateNode());
        return this;
    }
    forShare() {
        assert(typeof this._select !== 'undefined', 'FOR SHARE can be used only in a select statement');
        return this.add(new ForShareNode());
    }
    create(indexName) {
        if (this.indexesClause) {
            const createIndex = new CreateIndexNode(this.table, indexName);
            this.add(createIndex);
            return createIndex;
        }
        else {
            return this.add(new CreateNode(this.table.isTemporary));
        }
    }
    drop() {
        if (this.indexesClause) {
            const args = sliced(arguments);
            const dropIndex = new DropIndexNode(this.table, args);
            this.add(dropIndex);
            return dropIndex;
        }
        else {
            return this.add(new DropNode(this.table));
        }
    }
    truncate() {
        return this.add(new TruncateNode(this.table));
    }
    distinct() {
        return this.add(new DistinctNode());
    }
    distinctOn(...args) {
        let distinctOn;
        if (this._distinctOn) {
            distinctOn = this._distinctOn;
        }
        else {
            const select = this.nodes.filter((node) => node.type === 'SELECT').shift();
            distinctOn = this._distinctOn = new DistinctOnNode();
            select.add(distinctOn);
        }
        // allow things like .distinctOn(a.star(), [ a.id, a.name ])
        // this will flatten them into a single array
        const flattenedArgs = sliced(args).reduce((cur, next) => {
            if (Array.isArray(next)) {
                return cur.concat(next);
            }
            cur.push(next);
            return cur;
        }, []);
        distinctOn.addAll(flattenedArgs.map(nodeableOrTextNode));
        return this;
    }
    alter() {
        return this.add(new AlterNode());
    }
    rename(newName) {
        const renameClause = new RenameNode();
        if (typeof newName === 'string') {
            newName = new Column({
                name: newName,
                table: this.table
            });
        }
        renameClause.add(newName.toNode());
        this.nodes[0].add(renameClause);
        return this;
    }
    addColumn(column, dataType) {
        const addClause = new AddColumnNode();
        if (typeof column === 'string') {
            column = new Column({
                name: column,
                table: this.table
            });
        }
        if (dataType) {
            column.dataType = dataType;
        }
        addClause.add(column.toNode());
        this.nodes[0].add(addClause);
        return this;
    }
    dropColumn(column) {
        const dropClause = new DropColumnNode();
        if (typeof column === 'string') {
            column = new Column({
                name: column,
                table: this.table
            });
        }
        dropClause.add(column.toNode());
        this.nodes[0].add(dropClause);
        return this;
    }
    renameColumn(oldColumn, newColumn) {
        const renameClause = new RenameColumnNode();
        if (typeof oldColumn === 'string') {
            oldColumn = new Column({
                name: oldColumn,
                table: this.table
            });
        }
        if (typeof newColumn === 'string') {
            newColumn = new Column({
                name: newColumn,
                table: this.table
            });
        }
        renameClause.add(oldColumn.toNode());
        renameClause.add(newColumn.toNode());
        this.nodes[0].add(renameClause);
        return this;
    }
    limit(count) {
        return this.add(new ModifierNode(this, 'LIMIT', count));
    }
    offset(count) {
        return this.add(new ModifierNode(this, 'OFFSET', count));
    }
    exists() {
        assert(this.type === 'SUBQUERY', 'exists() can only be used on a subQuery');
        return new PrefixUnaryNode({
            left: this,
            operator: 'EXISTS'
        });
    }
    notExists() {
        assert(this.type === 'SUBQUERY', 'notExists() can only be used on a subQuery');
        return new PrefixUnaryNode({
            left: this,
            operator: 'NOT EXISTS'
        });
    }
    ifExists() {
        this.nodes[0].unshift(new IfExistsNode());
        return this;
    }
    ifNotExists() {
        this.nodes[0].unshift(new IfNotExistsNode());
        return this;
    }
    orIgnore() {
        this.nodes[0].unshift(new OrIgnoreNode());
        return this;
    }
    cascade() {
        this.nodes[0].add(new CascadeNode());
        return this;
    }
    restrict() {
        this.nodes[0].add(new RestrictNode());
        return this;
    }
    indexes() {
        this.indexesClause = new IndexesNode(this.table);
        return this.add(this.indexesClause);
    }
    createView(viewName) {
        this.add(new CreateViewNode(viewName));
        return this;
    }
}

class Dialect {
    constructor(config) {
        this.config = config;
        this.arrayAggFunctionName = 'array_agg';
        this.aliasText = ' AS ';
        this.quoteCharacter = '"';
        this.disableParameterPlaceholders = false;
        this.selectOrDeleteEndIndex = 0;
        this.visitedInsert = false;
        this.visitingUpdateTargetColumn = false;
        this.visitingCreate = false;
        this.visitCreateCompoundPrimaryKey = false;
        this.visitingAlter = false;
        this.visitingCast = false;
        this.visitingWhere = false;
        this.visitingCase = false;
        this.visitedReplace = false;
        this.visitingAddColumn = false;
        this.visitingReturning = false;
        this.visitingJoin = false;
        this.visitingFunctionCall = false;
        this.output = [];
        this.params = [];
    }
    _getParameterText(index, value) {
        return this.disableParameterPlaceholders ? this._getParameterValue(value).toString() : this._getParameterPlaceholder(index, value);
    }
    _getParameterValue(value, quoteChar) {
        // handle primitives
        if (null === value) {
            value = 'NULL';
        }
        else if ('boolean' === typeof value) {
            value = value ? 'TRUE' : 'FALSE';
        }
        else if ('number' === typeof value) {
            // number is just number
            value = value;
        }
        else if ('string' === typeof value) {
            // string uses single quote by default
            value = this.quote(value, quoteChar || "'");
        }
        else if ('object' === typeof value) {
            if (Array.isArray(value)) {
                value = map(value, (val) => this._getParameterValue(val, quoteChar));
                value = `(${value.join(', ')})`;
            }
            else if (value instanceof Date) {
                // Date object's default toString format does not get parsed well
                // Handle dates using custom dateToString method for postgres and toISOString for others
                value = this._getParameterValue(value.toISOString(), quoteChar);
            }
            else if (Buffer.isBuffer(value)) {
                value = this._getParameterValue('\\x' + value.toString('hex'), quoteChar);
            }
            else {
                // rich object represent with string
                const strValue = value.toString();
                value = strValue === '[object Object]' ? this._getParameterValue(JSON.stringify(value), quoteChar) : this._getParameterValue(strValue, quoteChar);
            }
        }
        else {
            throw new Error(`Unable to use ${value} in query`);
        }
        // value has been converted at this point
        return value;
    }
    _getParameterPlaceholder(index, value) {
        return '$' + index;
    }
    getQuery(queryNode) {
        // passed in a table, not a query
        if (queryNode instanceof Table) {
            queryNode = queryNode.select(queryNode.star());
        }
        this.output = this.visit(queryNode);
        // if is a create view, must replace paramaters with values
        if (this.output.indexOf('CREATE VIEW') > -1) {
            const previousFlagStatus = this.disableParameterPlaceholders;
            this.disableParameterPlaceholders = true;
            this.output = [];
            this.output = this.visit(queryNode);
            this.params = [];
            this.disableParameterPlaceholders = previousFlagStatus;
        }
        // create the query object
        const query = { text: this.output.join(' '), values: this.params };
        // reset the internal state of this builder
        this.output = [];
        this.params = [];
        return query;
    }
    getString(queryNode) {
        // switch off parameter placeholders
        const previousFlagStatus = this.disableParameterPlaceholders;
        this.disableParameterPlaceholders = true;
        let query;
        try {
            // use the same code path for query building
            query = this.getQuery(queryNode);
        }
        finally {
            // always restore the flag afterwards
            this.disableParameterPlaceholders = previousFlagStatus;
        }
        return query.text;
    }
    visit(node) {
        switch (node.type) {
            case 'QUERY':
                return this.visitQuery(node);
            case 'SUBQUERY':
                return this.visitSubquery(node);
            case 'SELECT':
                return this.visitSelect(node);
            case 'INSERT':
                return this.visitInsert(node);
            case 'REPLACE':
                return this.visitReplace(node);
            case 'UPDATE':
                return this.visitUpdate(node);
            case 'DELETE':
                return this.visitDelete(node);
            case 'CREATE':
                return this.visitCreate(node);
            case 'DROP':
                return this.visitDrop(node);
            case 'TRUNCATE':
                return this.visitTruncate(node);
            case 'DISTINCT':
                return this.visitDistinct(node);
            case 'DISTINCT ON':
                return this.visitDistinctOn(node);
            case 'ALIAS':
                return this.visitAlias(node);
            case 'ALTER':
                return this.visitAlter(node);
            case 'CAST':
                return this.visitCast(node);
            case 'FROM':
                return this.visitFrom(node);
            case 'WHERE':
                return this.visitWhere(node);
            case 'ORDER BY':
                return this.visitOrderBy(node);
            case 'ORDER BY VALUE':
                return this.visitOrderByValue(node);
            case 'GROUP BY':
                return this.visitGroupBy(node);
            case 'HAVING':
                return this.visitHaving(node);
            case 'RETURNING':
                return this.visitReturning(node);
            case 'ONDUPLICATE':
                return this.visitOnDuplicate(node);
            case 'ONCONFLICT':
                return this.visitOnConflict(node);
            case 'FOR UPDATE':
                return this.visitForUpdate(node);
            case 'FOR SHARE':
                return this.visitForShare(node);
            case 'TABLE':
                return this.visitTable(node);
            case 'COLUMN':
                return this.visitColumn(node);
            case 'FOREIGN KEY':
                return this.visitForeignKey(node);
            case 'JOIN':
                return this.visitJoin(node);
            case 'LITERAL':
                return this.visitLiteral(node);
            case 'TEXT':
                return this.visitText(node);
            case 'PARAMETER':
                return this.visitParameter(node);
            case 'DEFAULT':
                return this.visitDefault(node);
            case 'IF EXISTS':
                return this.visitIfExists(node);
            case 'IF NOT EXISTS':
                return this.visitIfNotExists(node);
            case 'OR IGNORE':
                return this.visitOrIgnore(node);
            case 'CASCADE':
                return this.visitCascade(node);
            case 'RESTRICT':
                return this.visitRestrict(node);
            case 'RENAME':
                return this.visitRename(node);
            case 'ADD COLUMN':
                return this.visitAddColumn(node);
            case 'DROP COLUMN':
                return this.visitDropColumn(node);
            case 'RENAME COLUMN':
                return this.visitRenameColumn(node);
            case 'INDEXES':
                return this.visitIndexes(node);
            case 'CREATE INDEX':
                return this.visitCreateIndex(node);
            case 'DROP INDEX':
                return this.visitDropIndex(node);
            case 'FUNCTION CALL':
                return this.visitFunctionCall(node);
            case 'ARRAY CALL':
                return this.visitArrayCall(node);
            case 'ROW CALL':
                return this.visitRowCall(node);
            case 'CREATE VIEW':
                return this.visitCreateView(node);
            case 'INTERVAL':
                return this.visitInterval(node);
            case 'POSTFIX UNARY':
                return this.visitPostfixUnary(node);
            case 'PREFIX UNARY':
                return this.visitPrefixUnary(node);
            case 'BINARY':
                return this.visitBinary(node);
            case 'TERNARY':
                return this.visitTernary(node);
            case 'IN':
                return this.visitIn(node);
            case 'NOT IN':
                return this.visitNotIn(node);
            case 'CASE':
                return this.visitCase(node);
            case 'AT':
                return this.visitAt(node);
            case 'SLICE':
                return this.visitSlice(node);
            case 'LIMIT':
            case 'OFFSET':
                return this.visitModifier(node);
            default:
                throw new Error(`Unrecognized node type ${node.type}`);
        }
    }
    quote(word, quoteCharacter) {
        const q = quoteCharacter != null ? quoteCharacter : this.quoteCharacter;
        // handle square brackets specially
        return q === '[' ? '[' + word + ']' : q + word.replace(new RegExp(q, 'g'), q + q) + q;
    }
    visitSelect(selectNode) {
        const result = ['SELECT'];
        if (selectNode.isDistinct) {
            result.push('DISTINCT');
        }
        const distinctOnNode = selectNode.nodes.filter((node) => node.type === 'DISTINCT ON').shift();
        const nonDistinctOnNodes = selectNode.nodes.filter((node) => node.type !== 'DISTINCT ON');
        if (distinctOnNode) {
            result.push(this.visit(distinctOnNode).join());
        }
        result.push(nonDistinctOnNodes.map(this.visit.bind(this)).join(', '));
        this.selectOrDeleteEndIndex = this.output.length + result.length;
        return result;
    }
    visitInsert(insertNode) {
        // don't use table.column for inserts
        this.visitedInsert = true;
        const result = ['INSERT', ...insertNode.nodes.map((n) => this.visit(n).join())];
        result.push(`INTO ${this.visit(this.queryNode.table.toNode()).join()}`);
        result.push(`(${insertNode.columns.map(this.visit.bind(this)).join(', ')})`);
        const paramNodes = insertNode.getParameters();
        if (paramNodes.length > 0) {
            const paramText = paramNodes
                .map((paramSet) => {
                return paramSet.map((param) => this.visit(param)).join(', ');
            })
                .map((param) => `(${param})`)
                .join(', ');
            result.push('VALUES', paramText);
            if (result.slice(2, 5).join(' ') === '() VALUES ()') {
                result.splice(2, 3, 'DEFAULT VALUES');
            }
        }
        this.visitedInsert = false;
        return result;
    }
    visitReplace(replaceNode) {
        throw new Error('Postgres does not support REPLACE.');
    }
    visitUpdate(updateNode) {
        // don't auto-generate from clause
        const params = [];
        /* jshint boss: true */
        for (const node of updateNode.nodes) {
            this.visitingUpdateTargetColumn = true;
            const targetCol = this.visit(node);
            this.visitingUpdateTargetColumn = false;
            params.push(`${targetCol} = ${this.visit(node.value)}`);
        }
        const result = ['UPDATE', this.visit(this.queryNode.table.toNode()).join(), 'SET', params.join(', ')];
        return result;
    }
    visitDelete(deleteNode) {
        const result = ['DELETE'];
        if (deleteNode.nodes.length) {
            result.push(deleteNode.nodes.map(this.visit.bind(this)).join(', '));
        }
        this.selectOrDeleteEndIndex = result.length;
        return result;
    }
    visitCreate(createNode) {
        this.visitingCreate = true;
        // don't auto-generate from clause
        const table = this.queryNode.table;
        const colNodes = table.columns.map((col) => col.toNode());
        const foreignKeyNodes = table.foreignKeys;
        let result = ['CREATE TABLE'];
        if (createNode.options.isTemporary) {
            result = ['CREATE TEMPORARY TABLE'];
        }
        result = result.concat(createNode.nodes.map((n) => this.visit(n).join()));
        result.push(this.visit(table.toNode()).join());
        const primaryColNodes = colNodes.filter((n) => n.primaryKey);
        this.visitCreateCompoundPrimaryKey = primaryColNodes.length > 1;
        let colspec = `(${colNodes.map((n) => this.visit(n).join()).join(', ')}`;
        if (this.visitCreateCompoundPrimaryKey) {
            colspec += `, PRIMARY KEY (${primaryColNodes.map((node) => this.quote(node.name)).join(', ')})`;
        }
        if (foreignKeyNodes.length > 0) {
            colspec += `, ${foreignKeyNodes.map((n) => this.visit(n).join()).join(', ')}`;
        }
        colspec += ')';
        result.push(colspec);
        this.visitCreateCompoundPrimaryKey = false;
        this.visitingCreate = false;
        return result;
    }
    visitDrop(dropNode) {
        // don't auto-generate from clause
        let result = ['DROP TABLE'];
        result = result.concat(dropNode.nodes.map((n) => this.visit(n).join()));
        return result;
    }
    visitTruncate(truncateNode) {
        let result = ['TRUNCATE TABLE'];
        result = result.concat(truncateNode.nodes.map((n) => this.visit(n).join()));
        return result;
    }
    visitDistinct(distinctNode) {
        // Nothing to do here since it's handled in the SELECT clause
        return [];
    }
    visitDistinctOn(distinctOnNode) {
        return [`DISTINCT ON(${distinctOnNode.nodes.map((n) => this.visit(n).join()).join(', ')})`];
    }
    visitAlias(aliasNode) {
        const result = [this.visit(aliasNode.value) + this.aliasText + this.quote(aliasNode.alias)];
        return result;
    }
    visitAlter(alterNode) {
        this.visitingAlter = true;
        // don't auto-generate from clause
        const table = this.queryNode.table;
        const result = ['ALTER TABLE', ...this.visit(table.toNode()), alterNode.nodes.map(this.visit.bind(this)).join(', ')];
        this.visitingAlter = false;
        return result;
    }
    visitCast(castNode) {
        this.visitingCast = true;
        const result = ['CAST(' + this.visit(castNode.value) + ' AS ' + castNode.dataType + ')'];
        this.visitingCast = false;
        return result;
    }
    visitFrom(fromNode) {
        let result = [];
        if (fromNode.skipFromStatement) {
            result.push(',');
        }
        else {
            result.push('FROM');
        }
        for (const node of fromNode.nodes) {
            result = result.concat(this.visit(node));
        }
        return result;
    }
    visitWhere(whereNode) {
        this.visitingWhere = true;
        const result = ['WHERE', whereNode.nodes.map(this.visit.bind(this)).join(', ')];
        this.visitingWhere = false;
        return result;
    }
    visitOrderBy(orderByNode) {
        const result = ['ORDER BY', orderByNode.nodes.map(this.visit.bind(this)).join(', ')];
        return result;
    }
    visitOrderByValue(orderByValueNode) {
        let text = this.visit(orderByValueNode.value).join();
        if (orderByValueNode.direction) {
            text += ' ' + this.visit(orderByValueNode.direction).join();
        }
        return [text];
    }
    visitGroupBy(groupByNode) {
        const result = ['GROUP BY', groupByNode.nodes.map(this.visit.bind(this)).join(', ')];
        return result;
    }
    visitHaving(havingNode) {
        const result = ['HAVING', havingNode.nodes.map(this.visit.bind(this)).join(' AND ')];
        return result;
    }
    visitPrefixUnary(prefixUnaryNode) {
        const text = '(' + prefixUnaryNode.operator + ' ' + this.visit(prefixUnaryNode.left) + ')';
        return [text];
    }
    visitPostfixUnary(postfixUnaryNode) {
        const text = '(' + this.visit(postfixUnaryNode.left) + ' ' + postfixUnaryNode.operator + ')';
        return [text];
    }
    visitBinary(binaryNode) {
        binaryNode.left.property = binaryNode.left.name;
        binaryNode.right.property = binaryNode.right.name;
        let text = `(${this.visit(binaryNode.left)} ${binaryNode.operator} `;
        text += Array.isArray(binaryNode.right) ? `(${binaryNode.right.map((node) => this.visit(node)).join(', ')})` : this.visit(binaryNode.right).join();
        text += ')';
        return [text];
    }
    visitTernary(ternaryNode) {
        const visitPart = (value) => {
            return Array.isArray(value) ? `(${value.map((node) => this.visit(node)).join(', ')})` : this.visit(value).join();
        };
        const text = `(${this.visit(ternaryNode.left)} ${ternaryNode.operator} ${visitPart(ternaryNode.middle)} ${ternaryNode.separator} ${visitPart(ternaryNode.right)})`;
        return [text];
    }
    visitIn(inNode) {
        let text = '(';
        if (Array.isArray(inNode.right)) {
            if (inNode.right.length) {
                const params = [];
                let hasNull = false;
                inNode.right.forEach((node) => {
                    if (node.type === 'PARAMETER' && node.value() === null) {
                        hasNull = true;
                    }
                    else {
                        params.push(this.visit(node).join());
                    }
                });
                if (params.length) {
                    text += `${this.visit(inNode.left)} IN (${params.join(', ')})`;
                    if (hasNull) {
                        text += ` OR ${this.visit(inNode.left)} IS NULL`;
                    }
                }
                else {
                    // implicitely has null
                    text += `${this.visit(inNode.left)} IS NULL`;
                }
            }
            else {
                text += '1=0';
            }
        }
        else {
            text += `${this.visit(inNode.left)} IN ${this.visit(inNode.right)}`;
        }
        text += ')';
        return [text];
    }
    visitNotIn(notInNode) {
        let text = '(';
        if (Array.isArray(notInNode.right)) {
            if (notInNode.right.length) {
                const params = [];
                let hasNull = false;
                notInNode.right.forEach((node) => {
                    if (node.type === 'PARAMETER' && node.value() === null) {
                        hasNull = true;
                    }
                    else {
                        params.push(this.visit(node).join());
                    }
                });
                if (params.length && hasNull) {
                    text += `NOT (${this.visit(notInNode.left)} IN (${params.join(', ')}) OR ${this.visit(notInNode.left)} IS NULL)`;
                }
                else if (params.length) {
                    text += `${this.visit(notInNode.left)} NOT IN (${params.join(', ')})`;
                }
                else {
                    // implicitely has null
                    text += `${this.visit(notInNode.left)} IS NOT NULL`;
                }
            }
            else {
                text += '1=1';
            }
        }
        else {
            text += `${this.visit(notInNode.left)} NOT IN ${this.visit(notInNode.right)}`;
        }
        text += ')';
        return [text];
    }
    visitCase(caseNode) {
        assert(caseNode.whenList.length === caseNode.thenList.length);
        let text = '(CASE';
        this.visitingCase = true;
        for (let i = 0; i < caseNode.whenList.length; i++) {
            text += ` WHEN ${this.visit(caseNode.whenList[i])} THEN ${this.visit(caseNode.thenList[i])}`;
        }
        if (caseNode.else != null) {
            text += ` ELSE ${this.visit(caseNode.else)}`;
        }
        this.visitingCase = false;
        text += ' END)';
        return [text];
    }
    visitAt(atNode) {
        const text = `(${this.visit(atNode.value)})[${this.visit(atNode.index)}]`;
        return [text];
    }
    visitSlice(sliceNode) {
        const text = `(${this.visit(sliceNode.value)})[${this.visit(sliceNode.start)}:${this.visit(sliceNode.end)}]`;
        return [text];
    }
    visitQuery(queryNode) {
        if (this.queryNode) {
            return this.visitSubquery(queryNode, dontParenthesizeSubQuery(this.queryNode));
        }
        this.queryNode = queryNode;
        // need to sort the top level query nodes on visitation priority
        // so select/insert/update/delete comes before from comes before where
        let missingFrom = true;
        let hasFrom = false;
        let createView;
        let isSelect = false;
        const actions = [];
        const targets = [];
        const filters = [];
        for (const node of queryNode.nodes) {
            switch (node.type) {
                case 'SELECT':
                    isSelect = true;
                case 'DELETE':
                    actions.push(node);
                    break;
                case 'INDEXES':
                case 'INSERT':
                case 'REPLACE':
                case 'UPDATE':
                case 'CREATE':
                case 'DROP':
                case 'TRUNCATE':
                case 'ALTER':
                    actions.push(node);
                    missingFrom = false;
                    break;
                case 'FROM':
                    node.skipFromStatement = hasFrom;
                    hasFrom = true;
                    missingFrom = false;
                    targets.push(node);
                    break;
                case 'CREATE VIEW':
                    createView = node;
                    break;
                default:
                    filters.push(node);
                    break;
            }
        }
        if (!actions.length) {
            // if no actions are given, guess it's a select
            actions.push(new SelectNode().add(new TextNode('*')));
            isSelect = true;
        }
        if (missingFrom && queryNode.table instanceof Table) {
            // the instanceof handles the situation where a sql.select(some expression) is used and there should be no FROM clause
            targets.push(new FromNode().add(queryNode.table));
        }
        if (createView) {
            if (isSelect) {
                actions.unshift(createView);
            }
            else {
                throw new Error('Create View requires a Select.');
            }
        }
        return this.visitQueryHelper(actions, targets, filters);
    }
    /**
     * We separate out this part of query building so it can be overridden by other implementations.
     *
     * @param {Node[]} actions
     * @param {Node[]} targets
     * @param {Node[]} filters
     * @returns {String[]}
     */
    visitQueryHelper(actions, targets, filters) {
        this.handleDistinct(actions, filters);
        // lazy-man sorting
        const sortedNodes = actions.concat(targets).concat(filters);
        for (const node of sortedNodes) {
            const res = this.visit(node);
            this.output = this.output.concat(res);
        }
        // implicit 'from'
        return this.output;
    }
    visitSubquery(queryNode, dontParenthesize) {
        // create another query builder of the current class to build the subquery
        const subQuery = this.createSubInstance();
        // let the subquery modify this instance's params array
        subQuery.params = this.params;
        // pass on the disable parameter placeholder flag
        const previousFlagStatus = subQuery.disableParameterPlaceholders;
        subQuery.disableParameterPlaceholders = this.disableParameterPlaceholders;
        try {
            subQuery.visitQuery(queryNode);
        }
        finally {
            // restore the flag
            subQuery.disableParameterPlaceholders = previousFlagStatus;
        }
        const alias = queryNode.alias;
        if (dontParenthesize) {
            return [subQuery.output.join(' ') + (alias ? ' ' + this.quote(alias) : '')];
        }
        return ['(' + subQuery.output.join(' ') + ')' + (alias ? ' ' + this.quote(alias) : '')];
    }
    visitTable(tableNode) {
        const table = tableNode.table;
        let txt = '';
        if (table.getSchema()) {
            txt = this.quote(table.getSchema());
            txt += '.';
        }
        txt += this.quote(table.getName());
        if (typeof table.alias === 'string') {
            txt += this.aliasText + this.quote(table.alias);
        }
        return [txt];
    }
    visitColumn(columnNode) {
        const table = columnNode.table;
        const inInsertUpdateClause = this.visitedInsert || this.visitedReplace || this.visitingUpdateTargetColumn;
        const inDdlClause = this.visitingAddColumn || this.visitingAlter || this.visitingCreate;
        const inSelectClause = this.visitingReturning ||
            (!this.selectOrDeleteEndIndex &&
                !this.visitingWhere &&
                !inInsertUpdateClause &&
                !inDdlClause &&
                !this.visitingCase &&
                !this.visitingJoin);
        const inFunctionCall = this.visitingFunctionCall;
        const inCast = this.visitingCast;
        const txt = [];
        let closeParen = 0;
        if (inSelectClause && ((table && !table.alias) || !!columnNode.alias)) {
            if (columnNode.asArray) {
                closeParen++;
                txt.push(`${this.arrayAggFunctionName}(`);
            }
            if (!!columnNode.aggregator) {
                closeParen++;
                txt.push(`${columnNode.aggregator}(`);
            }
            if (columnNode.isDistinct === true) {
                closeParen++;
                txt.push('DISTINCT(');
            }
        }
        if (!inInsertUpdateClause &&
            !this.visitingReturning &&
            !this.visitingCreate &&
            !this.visitingAlter &&
            !columnNode.subfieldContainer) {
            if (table) {
                if (typeof table.alias === 'string') {
                    txt.push(this.quote(table.alias));
                }
                else {
                    if (table.getSchema()) {
                        txt.push(this.quote(table.getSchema()));
                        txt.push('.');
                    }
                    txt.push(this.quote(table.getName()));
                }
                txt.push('.');
            }
        }
        if (columnNode.star) {
            const allCols = [];
            let hasAliases = false;
            if (columnNode.aggregator !== 'COUNT') {
                const tableName = txt.join('');
                for (const col of table.columns) {
                    const aliased = col.name !== (col.alias || col.property);
                    hasAliases = hasAliases || aliased;
                    allCols.push(tableName + this.quote(col.name) + (aliased ? this.aliasText + this.quote(col.alias || col.property) : ''));
                }
            }
            if (hasAliases) {
                txt.length = 0;
                txt.push(allCols.join(', '));
            }
            else {
                txt.push('*');
            }
        }
        else if (columnNode.isConstant) {
            // this injects directly into SELECT statement rather than creating a parameter
            //   txt.push(this._getParameterValue(columnNode.literalValue))
            // currently thinking it is better to generate a parameter
            const value = columnNode.constantValue;
            this.params.push(value);
            txt.push(this._getParameterText(this.params.length, value));
        }
        else {
            if (columnNode.subfieldContainer) {
                txt.push('(' + this.visitColumn(columnNode.subfieldContainer.toNode()) + ').');
            }
            txt.push(this.quote(columnNode.name));
        }
        if (closeParen) {
            for (let j = 0; j < closeParen; j++) {
                txt.push(')');
            }
        }
        if (inSelectClause && !inFunctionCall && !inCast && (columnNode.alias || columnNode.property !== columnNode.name)) {
            txt.push(this.aliasText + this.quote(columnNode.alias || columnNode.property));
        }
        if (this.visitingCreate || this.visitingAddColumn) {
            assert(columnNode.dataType, `dataType missing for column ${columnNode.name} (CREATE TABLE and ADD COLUMN statements require a dataType)`);
            txt.push(` ${columnNode.dataType}`);
            if (this.visitingCreate) {
                if (columnNode.primaryKey && !this.visitCreateCompoundPrimaryKey) {
                    // creating a column as a primary key
                    txt.push(' PRIMARY KEY');
                }
                else if (columnNode.notNull) {
                    txt.push(' NOT NULL');
                }
                if (!columnNode.primaryKey && columnNode.unique) {
                    txt.push(' UNIQUE');
                }
                if (columnNode.defaultValue !== undefined) {
                    txt.push(` DEFAULT ${this._getParameterValue(columnNode.defaultValue)}`);
                }
            }
            if (!!columnNode.references) {
                assert.strictEqual(typeof columnNode.references, 'object', 'references is not a object for column ' +
                    columnNode.name +
                    ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +
                    ' require refrences to be expressed as an object)');
                // Empty refrence objects are ok
                if (Object.keys(columnNode.references).length > 0) {
                    const references = columnNode.references;
                    assert(references.table, 'reference.table missing for column ' +
                        columnNode.name +
                        ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +
                        ' require a table and column)');
                    assert(references.column, 'reference.column missing for column ' +
                        columnNode.name +
                        ' (REFERENCES statements within CREATE TABLE and ADD COLUMN statements' +
                        ' require a table and column)');
                    txt.push(' REFERENCES ');
                    // TODO: if this is used need to put back in
                    // if (references.schema) {
                    //     txt.push(this.quote(references.schema) + '.');
                    // }
                    txt.push(this.quote(references.table) + '(' + this.quote(references.column) + ')');
                    let onDelete = references.onDelete;
                    if (onDelete) {
                        onDelete = onDelete.toUpperCase();
                    }
                    if (onDelete === 'CASCADE' ||
                        onDelete === 'RESTRICT' ||
                        onDelete === 'SET NULL' ||
                        onDelete === 'SET DEFAULT' ||
                        onDelete === 'NO ACTION') {
                        txt.push(` ON DELETE ${onDelete}`);
                    }
                    let onUpdate = references.onUpdate;
                    if (onUpdate) {
                        onUpdate = onUpdate.toUpperCase();
                    }
                    if (onUpdate === 'CASCADE' ||
                        onUpdate === 'RESTRICT' ||
                        onUpdate === 'SET NULL' ||
                        onUpdate === 'SET DEFAULT' ||
                        onUpdate === 'NO ACTION') {
                        txt.push(` ON UPDATE ${onUpdate}`);
                    }
                    const constraint = references.constraint;
                    if (constraint) {
                        txt.push(` ${constraint.toUpperCase()}`);
                    }
                }
            }
        }
        return [txt.join('')];
    }
    visitForeignKey(foreignKeyNode) {
        const txt = [];
        if (this.visitingCreate) {
            assert(foreignKeyNode.table, 'Foreign table missing for table reference');
            assert(foreignKeyNode.columns, 'Columns missing for table reference');
            if (foreignKeyNode.refColumns !== undefined) {
                assert.strictEqual(foreignKeyNode.columns.length, foreignKeyNode.refColumns.length, 'Number of local columns and foreign columns differ in table reference');
            }
            if (foreignKeyNode.name !== undefined) {
                txt.push('CONSTRAINT ' + this.quote(foreignKeyNode.name) + ' ');
            }
            txt.push('FOREIGN KEY ( ');
            for (let i = 0; i < foreignKeyNode.columns.length; i++) {
                if (i > 0) {
                    txt.push(', ');
                }
                txt.push(this.quote(foreignKeyNode.columns[i]));
            }
            txt.push(' ) REFERENCES ');
            if (foreignKeyNode.schema !== undefined) {
                txt.push(this.quote(foreignKeyNode.schema) + '.');
            }
            txt.push(this.quote(foreignKeyNode.table));
            if (foreignKeyNode.refColumns !== undefined) {
                txt.push(' ( ');
                for (let i = 0; i < foreignKeyNode.refColumns.length; i++) {
                    if (i > 0) {
                        txt.push(', ');
                    }
                    txt.push(this.quote(foreignKeyNode.refColumns[i]));
                }
                txt.push(' )');
            }
            let onDelete = foreignKeyNode.onDelete;
            if (onDelete) {
                onDelete = onDelete.toUpperCase();
                if (onDelete === 'CASCADE' ||
                    onDelete === 'RESTRICT' ||
                    onDelete === 'SET NULL' ||
                    onDelete === 'SET DEFAULT' ||
                    onDelete === 'NO ACTION') {
                    txt.push(` ON DELETE ${onDelete}`);
                }
            }
            let onUpdate = foreignKeyNode.onUpdate;
            if (onUpdate) {
                onUpdate = onUpdate.toUpperCase();
                if (onUpdate === 'CASCADE' ||
                    onUpdate === 'RESTRICT' ||
                    onUpdate === 'SET NULL' ||
                    onUpdate === 'SET DEFAULT' ||
                    onUpdate === 'NO ACTION') {
                    txt.push(` ON UPDATE ${onUpdate}`);
                }
            }
            if (foreignKeyNode.constraint) {
                txt.push(` ${foreignKeyNode.constraint.toUpperCase()}`);
            }
        }
        return [txt.join('')];
    }
    visitFunctionCall(functionCallNode) {
        this.visitingFunctionCall = true;
        const extract = () => {
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 1) {
                throw new Error(`Not enough parameters passed to ${functionCallNode.name} function`);
            }
            return `EXTRACT(${functionCallNode.name} FROM ${nodes[0] + ''})`;
        };
        let txt = '';
        // Override date functions since postgres (and others) uses extract
        if (['YEAR', 'MONTH', 'DAY', 'HOUR'].indexOf(functionCallNode.name) >= 0) {
            txt = extract();
        }
        // Override CURRENT_TIMESTAMP function to remove parens
        else if ('CURRENT_TIMESTAMP' === functionCallNode.name) {
            txt = functionCallNode.name;
        }
        else {
            txt = `${functionCallNode.name}(${functionCallNode.nodes.map(this.visit.bind(this)).join(', ')})`;
        }
        this.visitingFunctionCall = false;
        return [txt];
    }
    visitArrayCall(arrayCallNode) {
        const txt = `ARRAY[${arrayCallNode.nodes.map(this.visit.bind(this)).join(', ')}]`;
        return [txt];
    }
    visitRowCall(rowCallNode) {
        const txt = `(${rowCallNode.nodes.map(this.visit.bind(this)).join(', ')})`;
        return [txt];
    }
    visitParameter(parameterNode) {
        // save the value into the parameters array
        const value = parameterNode.value();
        this.params.push(value);
        return parameterNode.isExplicit ? [] : [this._getParameterText(this.params.length, value)];
    }
    visitDefault(defaultNode) {
        /* jshint unused: false */
        return ['DEFAULT'];
    }
    visitAddColumn(addColumnNode) {
        this.visitingAddColumn = true;
        const result = [`ADD COLUMN ${this.visit(addColumnNode.nodes[0])}`];
        this.visitingAddColumn = false;
        return result;
    }
    visitDropColumn(dropColumnNode) {
        return [`DROP COLUMN ${this.visit(dropColumnNode.nodes[0])}`];
    }
    visitRenameColumn(renameColumnNode) {
        return [`RENAME COLUMN ${this.visit(renameColumnNode.nodes[0])} TO ${this.visit(renameColumnNode.nodes[1])}`];
    }
    visitRename(renameNode) {
        return [`RENAME TO ${this.visit(renameNode.nodes[0])}`];
    }
    visitIfExists(ifExistsNode) {
        return ['IF EXISTS'];
    }
    visitIfNotExists(ifNotExistsNode) {
        return ['IF NOT EXISTS'];
    }
    visitOrIgnore(orIgnoreNode) {
        throw new Error('PostgreSQL does not allow orIgnore clause.');
    }
    visitCascade(cascadeNode) {
        return ['CASCADE'];
    }
    visitRestrict(restrictNode) {
        return ['RESTRICT'];
    }
    visitForUpdate(forUpdateNode) {
        return ['FOR UPDATE'];
    }
    visitForShare(forShareNode) {
        return ['FOR SHARE'];
    }
    visitJoin(joinNode) {
        this.visitingJoin = true;
        return [...this.visit(joinNode.from), `${joinNode.subType} JOIN`, ...this.visit(joinNode.to), 'ON', ...this.visit(joinNode.onNode)];
    }
    visitLiteral(literalNode) {
        const txt = [literalNode.literal];
        if (literalNode.alias) {
            txt.push(this.aliasText + this.quote(literalNode.alias));
        }
        return [txt.join('')];
    }
    visitText(textNode) {
        return [textNode.text];
    }
    visitReturning(returningNode) {
        this.visitingReturning = true;
        const r = ['RETURNING', returningNode.nodes.map(this.visit.bind(this)).join(', ')];
        this.visitingReturning = false;
        return r;
    }
    visitOnDuplicate(onDuplicateNode) {
        throw new Error('PostgreSQL does not allow onDuplicate clause.');
    }
    visitOnConflict(onConflictNode) {
        const result = ['ON CONFLICT'];
        const columns = [];
        const updateClause = [];
        let i;
        let col;
        const table = this.queryNode.table;
        if (onConflictNode.constraint) {
            result.push(['ON CONSTRAINT', this.quote(onConflictNode.constraint)].join(' '));
        }
        else if (onConflictNode.columns) {
            for (i = 0; i < onConflictNode.columns.length; i++) {
                columns.push(this.quote(table.getColumn(onConflictNode.columns[i]).name));
            }
            result.push('(' + columns.join(', ') + ')');
        }
        if (onConflictNode.update) {
            updateClause.push('DO UPDATE SET');
            const update = onConflictNode.update;
            const setClause = [];
            for (i = 0; i < update.length; i++) {
                col = this.quote(table.getColumn(update[i]).name);
                setClause.push(col + ' = EXCLUDED.' + col);
            }
            updateClause.push(setClause.join(', '));
        }
        else {
            updateClause.push('DO NOTHING');
        }
        result.push(updateClause.join(' '));
        return result;
    }
    visitModifier(modifierNode) {
        return [modifierNode.type, ...this.visit(modifierNode.count)];
    }
    visitIndexes(indexesNode) {
        /* jshint unused: false */
        const tableName = this.queryNode.table.getName();
        const schemaName = this.queryNode.table.getSchema() || 'public';
        return [
            'SELECT relname',
            'FROM pg_class',
            'WHERE oid IN (',
            'SELECT indexrelid',
            `FROM pg_index, pg_class WHERE pg_class.relname='${tableName}'`,
            `AND pg_class.relnamespace IN (SELECT pg_namespace.oid FROM pg_namespace WHERE nspname = '${schemaName}')`,
            'AND pg_class.oid=pg_index.indrelid)'
        ];
    }
    notEmpty(t) {
        return t !== undefined;
    }
    _visitCreateIndex(createIndexNode) {
        var _a, _b, _c;
        if (!createIndexNode.options.columns || createIndexNode.options.columns.length === 0) {
            throw new Error('No columns defined!');
        }
        const tableName = this.visit(createIndexNode.table.toNode());
        const ifNotExists = ((_a = createIndexNode.options) === null || _a === void 0 ? void 0 : _a.ifNotExists) ? this.visitIfNotExistsIndex() : [];
        const indexType = (_c = (_b = createIndexNode.options) === null || _b === void 0 ? void 0 : _b.type) === null || _c === void 0 ? void 0 : _c.toUpperCase();
        const indexName = this.quote(createIndexNode.indexName());
        const algorithm = createIndexNode.options.algorithm ? 'USING ' + createIndexNode.options.algorithm.toUpperCase() : undefined;
        const columns = '(' + createIndexNode.options.columns.reduce((res, col) => {
            const column = col.name ? col.name : col.value.name;
            const direction = col instanceof OrderByValueNode ? ` ${col.direction.text}` : '';
            return res.concat(this.quote(column) + direction);
        }, []) + ')';
        const parser = createIndexNode.options.parser ? 'WITH PARSER ' + createIndexNode.options.parser : undefined;
        return { indexType, ifNotExists, indexName, tableName, algorithm, columns, parser };
    }
    visitCreateIndex(createIndexNode) {
        const { indexType, ifNotExists, indexName, tableName, algorithm, columns, parser } = this._visitCreateIndex(createIndexNode);
        return [
            'CREATE',
            indexType,
            'INDEX',
            ...ifNotExists,
            indexName,
            'ON',
            ...tableName,
            algorithm,
            columns,
            parser
        ].filter(this.notEmpty);
    }
    visitIfNotExistsIndex() {
        return ['IF NOT EXISTS'];
    }
    visitDropIndex(dropIndexNode) {
        const ifExists = dropIndexNode.options.ifExists ? this.visitIfExistsIndex() : [];
        return [
            'DROP INDEX',
            ...ifExists,
            this.quote(dropIndexNode.table.getSchema() || 'public') + '.' + this.quote(dropIndexNode.options.indexName),
        ];
    }
    visitIfExistsIndex() {
        return ['IF EXISTS'];
    }
    visitCreateView(createViewNode) {
        const result = ['CREATE VIEW', this.quote(createViewNode.options.viewName), 'AS'];
        return result;
    }
    visitInterval(intervalNode) {
        let parameter = '';
        const add = (n, unit) => {
            if (!isNumber(n)) {
                return;
            }
            if (parameter !== '') {
                parameter += ' ';
            }
            parameter += `${n} ${unit}`;
        };
        add(intervalNode.years, 'YEAR');
        add(intervalNode.months, 'MONTH');
        add(intervalNode.days, 'DAY');
        add(intervalNode.hours, 'HOUR');
        add(intervalNode.minutes, 'MINUTE');
        add(intervalNode.seconds, 'SECOND');
        if (parameter === '') {
            parameter = '0 SECOND';
        }
        return [`INTERVAL '${parameter}'`];
    }
    /**
     * Broken out as a separate function so that dialects that derive from this class can still use this functionality.
     *
     * @param {Node[]} list
     * @param {String} type
     * @returns {Object|undefined} {index:number, node:Node}
     */
    findNode(list, type) {
        for (let i = 0, len = list.length; i < len; i++) {
            const n = list[i];
            if (n.type === type) {
                return { index: i, node: n };
            }
        }
        return undefined;
    }
    /**
     * pulls the DISTINCT node out of the filters and flags the SELECT node that it should be distinct.
     * Broken out as a separate function so that dialects that derive from this class can still use this functionality.
     */
    handleDistinct(actions, filters) {
        const distinctNode = this.findNode(filters, 'DISTINCT');
        // if (!distinctNode) distinctNode = _findNode(targets,"DISTINCT");
        // if (!distinctNode) distinctNode = _findNode(actions,"DISTINCT");
        if (!distinctNode) {
            return;
        }
        const selectInfo = this.findNode(actions, 'SELECT');
        if (!selectInfo) {
            return;
        } // there should be one by now, I think
        // mark the SELECT node that it's distinct
        selectInfo.node.isDistinct = true;
    }
}
/**
 * If the parent of the subquery is an INSERT we don't want to parenthesize.
 * This happens when you create the query like so:
 *
 * const query=post.insert(post.id)
 * const select=user.select(user.id)
 * query.add(select)
 *
 * @param parentQuery
 * @returns {boolean}
 */
const dontParenthesizeSubQuery = (parentQuery) => {
    if (!parentQuery) {
        return false;
    }
    if (parentQuery.nodes.length === 0) {
        return false;
    }
    if (['INSERT', 'REPLACE'].indexOf(parentQuery.nodes[0].type) === -1) {
        return false;
    }
    return true;
};

// TODO: visitCreate needs to support schemas
/**
 * Config can contain:
 *
 * questionMarkParameterPlaceholder:true which will use a "?" for the parameter placeholder instead of the @index.
 *
 * @param config
 * @constructor
 */
class Mssql extends Dialect {
    constructor(config) {
        super(config);
        this.quoteCharacter = '[';
        this.arrayAggFunctionName = '';
    }
    createSubInstance() {
        return new Mssql(this.config);
    }
    _getParameterPlaceholder(index, value) {
        if (this.config.questionMarkParameterPlaceholder) {
            return '?';
        }
        return `@${index}`;
    }
    visitReplace(replaceNode) {
        throw new Error('Mssql does not support REPLACE.');
    }
    visitBinary(binaryNode) {
        if (binaryNode.operator === '@@' && !Array.isArray(binaryNode.right)) {
            return [`(CONTAINS (${this.visit(binaryNode.left)}, ${this.visit(binaryNode.right)}))`];
        }
        if (!Array.isArray(binaryNode.right)) {
            return super.visitBinary(binaryNode);
        }
        if (binaryNode.operator === 'IN' || binaryNode.operator === 'NOT IN') {
            return super.visitBinary(binaryNode);
        }
        throw new Error('SQL Sever does not support arrays in this type of expression.');
    }
    visitAlter(alterNode) {
        const errMsg = 'ALTER TABLE cannot be used to perform multiple different operations in the same statement.';
        // Implement our own add column:
        //   PostgreSQL: ALTER TABLE "name" ADD COLUMN "col1", ADD COLUMN "col2"
        //   Mssql:  ALTER TABLE [name] ADD [col1], [col2]
        const addColumn = () => {
            this.visitingAlter = true;
            const table = this.queryNode.table;
            this.visitingAddColumn = true;
            let result = `ALTER TABLE ${this.visit(table.toNode())} ADD ${this.visit(alterNode.nodes[0].nodes[0])}`;
            for (let i = 1, len = alterNode.nodes.length; i < len; i++) {
                const node = alterNode.nodes[i];
                assert(node.type === 'ADD COLUMN', errMsg);
                result += `, ${this.visit(node.nodes[0])}`;
            }
            this.visitingAddColumn = false;
            this.visitingAlter = false;
            return [result];
        };
        // Implement our own drop column:
        //   PostgreSQL: ALTER TABLE "name" DROP COLUMN "col1", DROP COLUMN "col2"
        //   Mssql:  ALTER TABLE [name] DROP COLUMN [col1], [col2]
        const dropColumn = () => {
            this.visitingAlter = true;
            const table = this.queryNode.table;
            const result = ['ALTER TABLE', ...this.visit(table.toNode())];
            let columns = `DROP COLUMN ${this.visit(alterNode.nodes[0].nodes[0])}`;
            for (let i = 1, len = alterNode.nodes.length; i < len; i++) {
                const node = alterNode.nodes[i];
                assert(node.type === 'DROP COLUMN', errMsg);
                columns += `, ${this.visit(node.nodes[0])}`;
            }
            result.push(columns);
            this.visitingAlter = false;
            return result;
        };
        // Implement our own rename table:
        //   PostgreSQL: ALTER TABLE "post" RENAME TO "posts"
        //   Mssql:  EXEC sp_rename [post], [posts]
        const rename = () => {
            this.visitingAlter = true;
            const table = this.queryNode.table;
            const result = ['EXEC sp_rename ' + this.visit(table.toNode()) + ', ' + this.visit(alterNode.nodes[0].nodes[0])];
            this.visitingAlter = false;
            return result;
        };
        // Implement our own rename column:
        //   PostgreSQL: ALTER TABLE "group" RENAME COLUMN "userId" TO "newUserId"
        //   Mssql:  EXEC sp_rename '[group].[userId]', [newUserId]
        const renameColumn = () => {
            this.visitingAlter = true;
            const table = this.queryNode.table;
            const result = [
                `EXEC sp_rename '${this.visit(table.toNode())}.${this.visit(alterNode.nodes[0].nodes[0])}', ${this.visit(alterNode.nodes[0].nodes[1])}, 'COLUMN'`
            ];
            this.visitingAlter = false;
            return result;
        };
        if (isAlterAddColumn$1(alterNode)) {
            return addColumn();
        }
        if (isAlterDropColumn$1(alterNode)) {
            return dropColumn();
        }
        if (isAlterRename(alterNode)) {
            return rename();
        }
        if (isAlterRenameColumn(alterNode)) {
            return renameColumn();
        }
        return super.visitAlter(alterNode);
    }
    // Need to implement a special version of CASE since SQL doesn't support
    //   CASE WHEN true THEN xxx END
    //   the "true" has to be a boolean expression like 1=1
    visitCase(caseNode) {
        const whenValue = (node) => {
            if (node.type !== 'PARAMETER') {
                return this.visit(node);
            }
            // dealing with a true/false value
            const val = node.value();
            return val === true ? '1=1' : '0=1';
        };
        assert(caseNode.whenList.length === caseNode.thenList.length);
        let text = '(CASE';
        this.visitingCase = true;
        for (let i = 0; i < caseNode.whenList.length; i++) {
            text += ` WHEN ${whenValue(caseNode.whenList[i])} THEN ${this.visit(caseNode.thenList[i])}`;
        }
        if (caseNode.else != null) {
            text += ` ELSE ${this.visit(caseNode.else)}`;
        }
        this.visitingCase = false;
        text += ' END)';
        return [text];
    }
    visitColumn(columnNode) {
        let inSelectClause = false;
        const table = columnNode.table;
        inSelectClause = !this.selectOrDeleteEndIndex;
        const arrayAgg = () => {
            throw new Error('SQL Server does not support array_agg.');
        };
        const countStar = () => {
            // Implement our own since count(table.*) is invalid in Mssql
            let result = 'COUNT(*)';
            if (inSelectClause && columnNode.alias) {
                result += ` AS ${this.quote(columnNode.alias)}`;
            }
            return result;
        };
        if (isCountStarExpression$1(columnNode)) {
            return [countStar()];
        }
        if (inSelectClause && table && !table.alias && columnNode.asArray) {
            return arrayAgg();
        }
        return super.visitColumn(columnNode);
    }
    visitCreate(createNode) {
        const isNotExists = isCreateIfNotExists$1(createNode);
        const isTemporary = isCreateTemporary(createNode);
        if (!isNotExists && !isTemporary) {
            return super.visitCreate(createNode);
        }
        // Implement our own create if not exists:
        //   PostgreSQL: CREATE TABLE IF NOT EXISTS "group" ("id" constchar(100))
        //   Mssql:  IF NOT EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'group') BEGIN ... END
        const table = this.queryNode.table;
        const colNodes = table.columns.map((col) => col.toNode());
        const tableResult = this.visit(table.toNode());
        this.visitingCreate = true;
        const createResult = ['CREATE TABLE'];
        createResult.push(...tableResult);
        createResult.push(`(${colNodes.map(this.visit.bind(this)).join(', ')})`);
        this.visitingCreate = false;
        let tableStr = tableResult.join(' ');
        tableStr = tableStr.replace("'", "''");
        tableStr = `'${tableStr.substring(1, tableStr.length - 1)}'`;
        const whereClause = `WHERE TABLE_NAME = ${tableStr}`;
        // TODO: need to add schema check, sudo code:
        // if (schema) { whereClause+=' AND TABLE_SCHEMA = schemaResult.join(' ')}
        // Add some tests for this as well
        if (!isNotExists) {
            return createResult;
        }
        return [`IF NOT EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES ${whereClause}) BEGIN ${createResult.join(' ')} END`];
    }
    visitDrop(dropNode) {
        if (!isDropIfExists$1(dropNode)) {
            return super.visitDrop(dropNode);
        }
        // Implement our own drop if exists:
        //   PostgreSQL: DROP TABLE IF EXISTS "group"
        //   Mssql:  IF EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = [group]) BEGIN ... END
        const table = this.queryNode.table;
        const tableResult = this.visit(table.toNode());
        const dropResult = ['DROP TABLE'];
        dropResult.push(...tableResult);
        const whereClause = `WHERE TABLE_NAME = ${tableResult.join(' ')}`;
        // TODO: need to add schema check, sudo code:
        // if (schema) { whereClause+=' AND TABLE_SCHEMA = schemaResult.join(' ')}
        // Add some tests for this as well
        return [`IF EXISTS(SELECT * FROM INFORMATION_SCHEMA.TABLES ${whereClause}) BEGIN ${dropResult.join(' ')} END`];
    }
    visitFunctionCall(functionCallNode) {
        this.visitingFunctionCall = true;
        const extract = () => {
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 1) {
                throw new Error(`Not enough parameters passed to ${functionCallNode.name} function`);
            }
            return `DATEPART(${functionCallNode.name.toLowerCase()}, ${nodes[0] + ''})`;
        };
        let txt;
        // Override date functions since mssql uses datepart
        if (['YEAR', 'MONTH', 'DAY', 'HOUR'].indexOf(functionCallNode.name) >= 0) {
            txt = extract();
        }
        // Override CURRENT_TIMESTAMP function to remove parens
        else if ('CURRENT_TIMESTAMP' === functionCallNode.name) {
            txt = functionCallNode.name;
        }
        else {
            let name = functionCallNode.name;
            // override the LENGTH function since mssql calls it LEN
            if (name === 'LENGTH') {
                name = 'LEN';
            }
            txt = `${name}(${functionCallNode.nodes.map(this.visit.bind(this)).join(', ')})`;
        }
        this.visitingFunctionCall = false;
        return [txt];
    }
    visitOrderBy(orderByNode) {
        const result = super.visitOrderBy(orderByNode);
        const offsetNode = orderByNode.msSQLOffsetNode;
        const limitNode = orderByNode.msSQLLimitNode;
        if (!offsetNode && !limitNode) {
            return result;
        }
        assert(offsetNode, 'Something bad happened, should have had an msSQLOffsetNode here.');
        result.push('OFFSET ' + getModifierValue(this, offsetNode) + ' ROWS');
        if (!limitNode) {
            return result;
        }
        result.push('FETCH NEXT ' + getModifierValue(this, limitNode) + ' ROWS ONLY');
        return result;
    }
    /**
     * We override this so that we can deal with the LIMIT and OFFSET clauses specially since they have to become
     * part of the SELECT and ORDER BY clauses.
     *
     * Basically if there's an ORDER BY clause we attach OFFSET and LIMIT to it so that it can be processed by the
     * ORDER BY handler later.
     *
     * If there's a LIMIT clause without OFFSET, we attach it to the SELECT clause so we can process it later.
     *
     * @param {Node[]} actions
     * @param {Node[]} targets
     * @param {Node[]} filters
     * @returns {String[]}
     */
    visitQueryHelper(actions, targets, filters) {
        const handleLimitAndOffset = () => {
            const limitInfo = super.findNode(filters, 'LIMIT');
            const offsetInfo = super.findNode(filters, 'OFFSET');
            const orderByInfo = super.findNode(filters, 'ORDER BY');
            // no OFFSET or LIMIT then there's nothing special to do
            if (!offsetInfo && !limitInfo) {
                return;
            }
            // ORDER BY with OFFSET we have work to do, may consume LIMIT as well
            if (orderByInfo && offsetInfo) {
                processOrderByOffsetLimit(orderByInfo, offsetInfo, limitInfo);
            }
            else if (offsetInfo) {
                throw new Error('MS SQL Server does not allow OFFSET without ORDER BY');
            }
            else if (limitInfo) {
                processLimit(limitInfo);
            }
        };
        /**
         * We need to turn LIMIT into a TOP clause on the SELECT STATEMENT
         *
         * @param limitInfo
         * @private
         */
        const processLimit = (limitInfo) => {
            const selectInfo = super.findNode(actions, 'SELECT');
            assert(selectInfo !== undefined, 'MS SQL Server requires a SELECT clause when using LIMIT');
            // save the LIMIT node with the SELECT node
            selectInfo.node.msSQLLimitNode = limitInfo.node;
            // remove the LIMIT node from the filters so it doesn't get processed later.
            filters.splice(limitInfo.index, 1);
        };
        /**
         * We need to turn LIMIT into a TOP clause on the SELECT STATEMENT
         *
         * @param orderByInfo
         * @param offsetInfo
         * @param limitInfo
         * @private
         */
        const processOrderByOffsetLimit = (orderByInfo, offsetInfo, limitInfo) => {
            // save the OFFSET AND LIMIT nodes with the ORDER BY node
            orderByInfo.node.msSQLOffsetNode = offsetInfo.node;
            if (limitInfo) {
                orderByInfo.node.msSQLLimitNode = limitInfo.node;
            }
            // remove the OFFSET and LIMIT nodes from the filters so they don't get processed later.
            filters.splice(offsetInfo.index, 1);
            if (limitInfo) {
                filters.splice(limitInfo.index, 1);
            }
        };
        // MAIN
        super.handleDistinct(actions, filters);
        handleLimitAndOffset();
        // lazy-man sorting
        const sortedNodes = actions.concat(targets).concat(filters);
        for (const node of sortedNodes) {
            const res = this.visit(node);
            this.output = this.output.concat(res);
        }
        return this.output;
    }
    // Mysql.prototype.visitRenameColumn = function(renameColumn) {
    //  const dataType = renameColumn.nodes[1].dataType || renameColumn.nodes[0].dataType;
    //  assert(dataType, 'dataType missing for column ' + (renameColumn.nodes[1].name || renameColumn.nodes[0].name || '') +
    //    ' (CHANGE COLUMN statements require a dataType)');
    //  return ['CHANGE COLUMN ' + this.visit(renameColumn.nodes[0]) + ' ' + this.visit(renameColumn.nodes[1]) + ' ' + dataType];
    // };
    //
    // Mysql.prototype.visitInsert = function(insert) {
    //  const result = Postgres.prototype.visitInsert.call(this, insert);
    //  if (result[2] === 'DEFAULT VALUES') {
    //    result[2] = '() VALUES ()';
    //  }
    //  return result;
    // };
    //
    // Mysql.prototype.visitIndexes = function(node) {
    //  const tableName = this.visit(this._queryNode.table.toNode());
    //
    //  return "SHOW INDEX FROM " + tableName;
    // };
    visitCreateIndex(createIndexNode) {
        const { indexType, ifNotExists, indexName, tableName, algorithm, columns, parser } = this._visitCreateIndex(createIndexNode);
        return [
            'CREATE',
            indexType,
            'INDEX',
            ...ifNotExists,
            indexName,
            algorithm,
            'ON',
            ...tableName,
            columns,
            parser
        ].filter(this.notEmpty);
    }
    visitIfNotExistsIndex() {
        throw new Error('MSSQL does not allow ifNotExists clause on indexes.');
    }
    visitOnDuplicate(onDuplicateNode) {
        throw new Error('MSSQL does not allow onDuplicate clause.');
    }
    visitOnConflict(onConflictNode) {
        throw new Error('MSSQL does not allow onConflict clause.');
    }
    visitReturning(returningNode) {
        // TODO: need to add some code to the INSERT clause to support this since its the equivalent of the OUTPUT clause
        // in MS SQL which appears before the values, not at the end of the statement.
        throw new Error('Returning clause is not yet supported for MS SQL.');
    }
    // We deal with SELECT specially so we can add the TOP clause if needed
    visitSelect(selectNode) {
        if (!selectNode.msSQLLimitNode) {
            return super.visitSelect(selectNode);
        }
        const result = [
            'SELECT',
            'TOP(' + getModifierValue(this, selectNode.msSQLLimitNode) + ')',
            selectNode.nodes.map(this.visit.bind(this)).join(', ')
        ];
        this.selectOrDeleteEndIndex = this.output.length + result.length;
        return result;
    }
}
// Node is either an OFFSET or LIMIT node
const getModifierValue = (dialect, node) => {
    return node.count.type ? dialect.visit(node.count) : node.count;
};
const isAlterAddColumn$1 = (alterNode) => {
    if (alterNode.nodes.length === 0) {
        return false;
    }
    if (alterNode.nodes[0].type !== 'ADD COLUMN') {
        return false;
    }
    return true;
};
const isAlterDropColumn$1 = (alterNode) => {
    if (alterNode.nodes.length === 0) {
        return false;
    }
    if (alterNode.nodes[0].type !== 'DROP COLUMN') {
        return false;
    }
    return true;
};
const isAlterRename = (alterNode) => {
    if (alterNode.nodes.length === 0) {
        return false;
    }
    if (alterNode.nodes[0].type !== 'RENAME') {
        return false;
    }
    return true;
};
const isAlterRenameColumn = (alterNode) => {
    if (alterNode.nodes.length === 0) {
        return false;
    }
    if (alterNode.nodes[0].type !== 'RENAME COLUMN') {
        return false;
    }
    return true;
};
const isCountStarExpression$1 = (columnNode) => {
    if (!columnNode.aggregator) {
        return false;
    }
    if (columnNode.aggregator.toLowerCase() !== 'count') {
        return false;
    }
    if (!columnNode.star) {
        return false;
    }
    return true;
};
const isCreateIfNotExists$1 = (createNode) => {
    if (createNode.nodes.length === 0) {
        return false;
    }
    if (createNode.nodes[0].type !== 'IF NOT EXISTS') {
        return false;
    }
    return true;
};
const isCreateTemporary = (createNode) => {
    return createNode.options.isTemporary;
};
const isDropIfExists$1 = (dropNode) => {
    if (dropNode.nodes.length === 0) {
        return false;
    }
    if (dropNode.nodes[0].type !== 'IF EXISTS') {
        return false;
    }
    return true;
};

class Mysql extends Dialect {
    constructor(config) {
        super(config);
        this.quoteCharacter = '`';
        this.arrayAggFunctionName = 'GROUP_CONCAT';
    }
    createSubInstance() {
        return new Mysql(this.config);
    }
    _getParameterPlaceholder(index, value) {
        return '?';
    }
    _getParameterValue(value, quoteChar) {
        return Buffer.isBuffer(value)
            ? 'x' + this._getParameterValue(value.toString('hex'), quoteChar)
            : super._getParameterValue(value, quoteChar);
    }
    visitReplace(replaceNode) {
        // don't use table.column for replaces
        this.visitedReplace = true;
        const result = [
            'REPLACE',
            ...replaceNode.nodes.map((n) => this.visit(n).join()),
            `INTO ${this.visit(this.queryNode.table.toNode())}`,
            `(${replaceNode.columns.map((n) => this.visit(n).join()).join(', ')})`
        ];
        const paramNodes = replaceNode.getParameters();
        if (paramNodes.length > 0) {
            const paramText = paramNodes
                .map((paramSet) => {
                return paramSet.map((param) => this.visit(param).join()).join(', ');
            })
                .map((param) => `(${param})`)
                .join(', ');
            result.push('VALUES', paramText);
            if (result.slice(2, 5).join(' ') === '() VALUES ()') {
                result.splice(2, 3, 'DEFAULT VALUES');
            }
        }
        this.visitedReplace = false;
        if (result[2] === 'DEFAULT VALUES') {
            result[2] = '() VALUES ()';
        }
        return result;
    }
    visitOnDuplicate(onDuplicateNode) {
        const params = [];
        /* jshint boss: true */
        for (const node of onDuplicateNode.nodes) {
            const targetCol = this.visit(node);
            params.push(`${targetCol} = ${this.visit(node.value)}`);
        }
        const result = ['ON DUPLICATE KEY UPDATE', params.join(', ')];
        return result;
    }
    visitOnConflict(onConflictNode) {
        throw new Error('Mysql does not allow onConflict clause.');
    }
    visitReturning(returningNode) {
        throw new Error('MySQL does not allow returning clause.');
    }
    visitForShare(forShareNode) {
        throw new Error('MySQL does not allow FOR SHARE clause.');
    }
    visitCreate(createNode) {
        const result = super.visitCreate(createNode);
        const engine = this.queryNode.table.initialConfig.engine;
        const charset = this.queryNode.table.initialConfig.charset;
        if (!!engine) {
            result.push('ENGINE=' + engine);
        }
        if (!!charset) {
            result.push('DEFAULT CHARSET=' + charset);
        }
        return result;
    }
    visitRenameColumn(renameColumnNode) {
        const dataType = renameColumnNode.nodes[1].dataType || renameColumnNode.nodes[0].dataType;
        assert(dataType, 'dataType missing for column ' +
            (renameColumnNode.nodes[1].name || renameColumnNode.nodes[0].name || '') +
            ' (CHANGE COLUMN statements require a dataType)');
        return [`CHANGE COLUMN ${this.visit(renameColumnNode.nodes[0])} ${this.visit(renameColumnNode.nodes[1])} ${dataType}`];
    }
    visitInsert(insertNode) {
        const result = super.visitInsert(insertNode);
        if (result[2] === 'DEFAULT VALUES') {
            result[2] = '() VALUES ()';
        }
        return result;
    }
    visitIndexes(indexesNode) {
        const tableName = this.visit(this.queryNode.table.toNode())[0];
        return [`SHOW INDEX FROM ${tableName}`];
    }
    visitCreateIndex(createIndexNode) {
        const { indexType, ifNotExists, indexName, tableName, algorithm, columns, parser } = this._visitCreateIndex(createIndexNode);
        return [
            'CREATE',
            indexType,
            'INDEX',
            ...ifNotExists,
            indexName,
            algorithm,
            'ON',
            ...tableName,
            columns,
            parser
        ].filter(this.notEmpty);
    }
    visitIfNotExistsIndex() {
        throw new Error('MySQL does not allow ifNotExists clause on indexes.');
    }
    visitIfExistsIndex() {
        throw new Error('MySQL does not allow ifExists clause on indexes.');
    }
    visitBinary(binaryNode) {
        if (binaryNode.operator === '@@' && !Array.isArray(binaryNode.right)) {
            return [`(MATCH ${this.visit(binaryNode.left)} AGAINST ${this.visit(binaryNode.right)})`];
        }
        return super.visitBinary(binaryNode);
    }
    visitFunctionCall(functionCallNode) {
        this.visitingFunctionCall = true;
        const extract = () => {
            const nodes = functionCallNode.nodes.map((n) => this.visit(n).join());
            if (nodes.length !== 1) {
                throw new Error(`Not enough parameters passed to ${functionCallNode.name} function`);
            }
            return `${functionCallNode.name}(${nodes[0]})`;
        };
        let txt = '';
        const name = functionCallNode.name;
        // Override date functions since mysql is different than postgres
        if (['YEAR', 'MONTH', 'DAY', 'HOUR'].indexOf(functionCallNode.name) >= 0) {
            txt = extract();
        }
        // Override CURRENT_TIMESTAMP function to remove parens
        else if ('CURRENT_TIMESTAMP' === functionCallNode.name) {
            txt = functionCallNode.name;
        }
        else {
            txt = `${name}(${functionCallNode.nodes.map((n) => this.visit(n).join()).join(', ')})`;
        }
        this.visitingFunctionCall = false;
        return [txt];
    }
    visitColumn(columnNode) {
        let inSelectClause = false;
        inSelectClause = !this.selectOrDeleteEndIndex;
        const isCountStarExpression = (node) => {
            if (!node.aggregator) {
                return false;
            }
            if (node.aggregator.toLowerCase() !== 'count') {
                return false;
            }
            if (!node.star) {
                return false;
            }
            return true;
        };
        const countStar = () => {
            // Implement our own since count(table.*) is invalid in Mysql
            let result = 'COUNT(*)';
            if (inSelectClause && columnNode.alias) {
                result += ` AS ${this.quote(columnNode.alias)}`;
            }
            return result;
        };
        if (isCountStarExpression(columnNode)) {
            return [countStar()];
        }
        return super.visitColumn(columnNode);
    }
    visitInterval(intervalNode) {
        let parameter;
        if (isNumber(intervalNode.years)) {
            parameter = isNumber(intervalNode.months)
                ? `'${intervalNode.years}-${intervalNode.months}' YEAR_MONTH`
                : `${intervalNode.years} YEAR`;
        }
        else if (isNumber(intervalNode.months)) {
            parameter = `${intervalNode.months} MONTH`;
        }
        else if (isNumber(intervalNode.days)) {
            parameter = `'${intervalNode.days} ${isNumber(intervalNode.hours) ? intervalNode.hours : 0}:${isNumber(intervalNode.minutes) ? intervalNode.minutes : 0}:${isNumber(intervalNode.seconds) ? intervalNode.seconds : 0}' DAY_SECOND`;
        }
        else {
            parameter = `'${isNumber(intervalNode.hours) ? intervalNode.hours : 0}:${isNumber(intervalNode.minutes) ? intervalNode.minutes : 0}:${isNumber(intervalNode.seconds) ? intervalNode.seconds : 0}' HOUR_SECOND`;
        }
        return [`INTERVAL ${parameter}`];
    }
}

class Oracle extends Dialect {
    constructor(config) {
        super(config);
        this.aliasText = ' ';
    }
    createSubInstance() {
        return new Oracle(this.config);
    }
    _getParameterValue(value, quoteChar) {
        return Buffer.isBuffer(value)
            ? "utl_raw.cast_to_varchar2(hextoraw('" + value.toString('hex') + "'))"
            : super._getParameterValue(value, quoteChar);
    }
    _getParameterPlaceholder(index, value) {
        return `:${index}`;
    }
    visitReplace(replaceNode) {
        throw new Error('Oracle does not support REPLACE.');
    }
    visitAlias(aliasNode) {
        const result = [this.visit(aliasNode.value) + ' ' + this.quote(aliasNode.alias)];
        return result;
    }
    visitAlter(alterNode) {
        const errMsg = 'ALTER TABLE cannot be used to perform multiple different operations in the same statement.';
        // Implement our own add column:
        //   PostgreSQL: ALTER TABLE "name" ADD COLUMN "col1", ADD COLUMN "col2"
        //   Oracle:  ALTER TABLE "name" ADD ("col1", "col2")
        const addColumn = () => {
            this.visitingAlter = true;
            const table = this.queryNode.table;
            this.visitingAddColumn = true;
            let result = 'ALTER TABLE ' + this.visit(table.toNode()) + ' ADD (' + this.visit(alterNode.nodes[0].nodes[0]);
            for (let i = 1, len = alterNode.nodes.length; i < len; i++) {
                const node = alterNode.nodes[i];
                assert(node.type === 'ADD COLUMN', errMsg);
                result += ', ' + this.visit(node.nodes[0]);
            }
            result += ')';
            this.visitingAddColumn = false;
            this.visitingAlter = false;
            return [result];
        };
        // Implement our own drop column:
        //   PostgreSQL: ALTER TABLE "name" DROP COLUMN "col1", DROP COLUMN "col2"
        //   Oracle:  ALTER TABLE "name" DROP ("col1", "col2")
        const dropColumn = () => {
            this.visitingAlter = true;
            const table = this.queryNode.table;
            const result = ['ALTER TABLE', ...this.visit(table.toNode())];
            let columns = 'DROP (' + this.visit(alterNode.nodes[0].nodes[0]);
            for (let i = 1, len = alterNode.nodes.length; i < len; i++) {
                const node = alterNode.nodes[i];
                assert(node.type === 'DROP COLUMN', errMsg);
                columns += ', ' + this.visit(node.nodes[0]);
            }
            columns += ')';
            result.push(columns);
            this.visitingAlter = false;
            return result;
        };
        if (isAlterAddColumn(alterNode)) {
            return addColumn();
        }
        if (isAlterDropColumn(alterNode)) {
            return dropColumn();
        }
        return super.visitAlter(alterNode);
    }
    visitTable(tableNode) {
        const table = tableNode.table;
        let txt = '';
        if (table.getSchema()) {
            txt = this.quote(table.getSchema());
            txt += '.';
        }
        txt += this.quote(table.getName());
        if (table.alias) {
            txt += ' ' + this.quote(table.alias);
        }
        return [txt];
    }
    visitCascade(cascadeNode) {
        return ['CASCADE CONSTRAINTS'];
    }
    visitRestrict(restrictNode) {
        throw new Error('Oracle do not support RESTRICT in DROP TABLE');
    }
    visitDrop(dropNode) {
        if (!isDropIfExists(dropNode)) {
            return super.visitDrop(dropNode);
        }
        // Implement our own drop if exists:
        //   PostgreSQL: DROP TABLE IF EXISTS "group"
        //   Oracle:
        //     BEGIN
        //          EXECUTE IMMEDIATE 'DROP TABLE POST';
        //     EXCEPTION
        //          WHEN OTHERS THEN
        //                 IF SQLCODE != -942 THEN
        //                      RAISE;
        //                 END IF;
        //     END;
        const table = this.queryNode.table;
        const tableResult = this.visit(table.toNode());
        const dropResult = ['DROP TABLE'];
        dropResult.push(...tableResult);
        return [
            "BEGIN EXECUTE IMMEDIATE '" + dropResult.join(' ') + "'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;"
        ];
    }
    visitCreate(createNode) {
        const isNotExists = isCreateIfNotExists(createNode);
        // const isTemporary=isCreateTemporary(create)
        let createText = super.visitCreate(createNode);
        if (isNotExists) {
            // Implement our own create if not exists:
            //   PostgreSQL: CREATE TABLE IF NOT EXISTS "group" ("id" constchar(100))
            //   Oracle:
            //     BEGIN
            //          EXECUTE IMMEDIATE 'CREATE TABLE ...';
            //     EXCEPTION
            //          WHEN OTHERS THEN
            //                 IF SQLCODE != -955 THEN
            //                      RAISE;
            //                 END IF;
            //     END;
            createText = [
                "BEGIN EXECUTE IMMEDIATE '" +
                    createText.join(' ').replace(' IF NOT EXISTS', '') +
                    "'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;"
            ];
        }
        return createText;
    }
    visitBinary(binaryNode) {
        if (binaryNode.operator === '@@' && !Array.isArray(binaryNode.right)) {
            let text = '(INSTR (' + this.visit(binaryNode.left) + ', ';
            text += this.visit(binaryNode.right);
            text += ') > 0)';
            return [text];
        }
        if (!Array.isArray(binaryNode.right)) {
            return super.visitBinary(binaryNode);
        }
        if (binaryNode.operator === 'IN' || binaryNode.operator === 'NOT IN') {
            return super.visitBinary(binaryNode);
        }
        throw new Error('Oracle does not support arrays in this type of expression.');
    }
    visitModifier(modifierNode) {
        const ret = super.visitModifier(modifierNode);
        if (ret.indexOf('OFFSET') >= 0) {
            ret.push('ROWS');
        }
        if (ret.indexOf('LIMIT') >= 0) {
            ret[0] = 'FETCH NEXT';
            ret.push('ROWS ONLY');
        }
        return ret;
    }
    visitQueryHelper(actions, targets, filters) {
        const output = super.visitQueryHelper(actions, targets, filters);
        // In Oracle, OFFSET must come before FETCH NEXT (limit)
        // Change positions, if both are present and not done already
        const offset = output.indexOf('OFFSET');
        const limit = output.indexOf('FETCH NEXT');
        if (offset !== -1 && limit !== -1 && offset > limit) {
            const temp = [output[offset], output[offset + 1], output[offset + 2]];
            output[offset] = output[limit];
            output[offset + 1] = output[limit + 1];
            output[offset + 2] = output[limit + 2];
            output[limit] = temp[0];
            output[limit + 1] = temp[1];
            output[limit + 2] = temp[2];
        }
        return this.output;
    }
    visitColumn(columnNode) {
        const table = columnNode.table;
        const inSelectClause = !this.selectOrDeleteEndIndex;
        const arrayAgg = () => {
            throw new Error('Oracle does not support array_agg.');
        };
        const countStar = () => {
            // Implement our own since count(table.*) is invalid in Oracle
            let result = 'COUNT(*)';
            if (inSelectClause && columnNode.alias) {
                result += this.aliasText + this.quote(columnNode.alias);
            }
            return [result];
        };
        if (isCountStarExpression(columnNode)) {
            return countStar();
        }
        if (inSelectClause && table && !table.alias && columnNode.asArray) {
            return arrayAgg();
        }
        return super.visitColumn(columnNode);
    }
    visitReturning(returningNode) {
        // TODO: need to add some code to the INSERT clause to support this since its the equivalent of the OUTPUT clause
        // in MS SQL which appears before the values, not at the end of the statement.
        throw new Error('Returning clause is not yet supported for Oracle.');
    }
    visitIndexes(indexesNode) {
        const tableName = this.queryNode.table.getName();
        const schemaName = this.queryNode.table.getSchema();
        let indexes = "SELECT * FROM USER_INDEXES WHERE TABLE_NAME = '" + tableName + "'";
        if (schemaName) {
            indexes += " AND TABLE_OWNER = '" + schemaName + "'";
        }
        return [indexes];
    }
    visitCreateIndex(createIndexNode) {
        const { indexType, ifNotExists, indexName, tableName, algorithm, columns, parser } = this._visitCreateIndex(createIndexNode);
        return [
            'CREATE',
            indexType,
            'INDEX',
            ...ifNotExists,
            indexName,
            algorithm,
            'ON',
            ...tableName,
            columns,
            parser
        ].filter(this.notEmpty);
    }
    visitDropIndex(dropIndexNode) {
        if (dropIndexNode.options.ifExists) {
            throw new Error('Oracle does not allow ifExists clause on indexes.');
        }
        const result = ['DROP INDEX'];
        const schemaName = dropIndexNode.table.getSchema();
        if (schemaName) {
            result.push(this.quote(schemaName) + '.');
        }
        result.push(this.quote(dropIndexNode.options.indexName));
        return result;
    }
    visitIfNotExistsIndex() {
        throw new Error('Oracle does not allow ifNotExists clause on indexes.');
    }
    // Need to implement a special version of CASE since Oracle doesn't support
    //   CASE WHEN true THEN xxx END
    //   the "true" has to be a boolean expression like 1=1
    visitCase(caseNode) {
        const whenValue = (node) => {
            if (node.type !== 'PARAMETER') {
                return this.visit(node);
            }
            // dealing with a true/false value
            const val = node.value();
            return val === true ? '1=1' : '0=1';
        };
        assert(caseNode.whenList.length === caseNode.thenList.length);
        let text = '(CASE';
        this.visitingCase = true;
        for (let i = 0; i < caseNode.whenList.length; i++) {
            text += ` WHEN ${whenValue(caseNode.whenList[i])} THEN ${this.visit(caseNode.thenList[i])}`;
        }
        if (caseNode.else != null) {
            text += ` ELSE ${this.visit(caseNode.else)}`;
        }
        this.visitingCase = false;
        text += ' END)';
        return [text];
    }
    visitOnConflict(onConflictNode) {
        throw new Error('Oracle does not allow onConflict clause.');
    }
}
const isCreateIfNotExists = (createNode) => {
    if (createNode.nodes.length === 0) {
        return false;
    }
    if (createNode.nodes[0].type !== 'IF NOT EXISTS') {
        return false;
    }
    return true;
};
const isDropIfExists = (dropNode) => {
    if (dropNode.nodes.length === 0) {
        return false;
    }
    if (dropNode.nodes[0].type !== 'IF EXISTS') {
        return false;
    }
    return true;
};
const isCountStarExpression = (columnNode) => {
    if (!columnNode.aggregator) {
        return false;
    }
    if (columnNode.aggregator.toLowerCase() !== 'count') {
        return false;
    }
    if (!columnNode.star) {
        return false;
    }
    return true;
};
const isAlterAddColumn = (alterNode) => {
    if (alterNode.nodes.length === 0) {
        return false;
    }
    if (alterNode.nodes[0].type !== 'ADD COLUMN') {
        return false;
    }
    return true;
};
const isAlterDropColumn = (alterNode) => {
    if (alterNode.nodes.length === 0) {
        return false;
    }
    if (alterNode.nodes[0].type !== 'DROP COLUMN') {
        return false;
    }
    return true;
};

const dateToStringUTC = (date) => {
    let year = date.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
        year = Math.abs(year) + 1; // negative years are 1 off their BC representation
    let ret = padStart(String(year), 4, '0') +
        '-' +
        padStart(String(date.getUTCMonth() + 1), 2, '0') +
        '-' +
        padStart(String(date.getUTCDate()), 2, '0') +
        'T' +
        padStart(String(date.getUTCHours()), 2, '0') +
        ':' +
        padStart(String(date.getUTCMinutes()), 2, '0') +
        ':' +
        padStart(String(date.getUTCSeconds()), 2, '0') +
        '.' +
        padStart(String(date.getUTCMilliseconds()), 3, '0');
    ret += 'Z';
    if (isBCYear)
        ret += ' BC';
    return ret;
};
/**
 * Config can contain:
 *
 * nullOrder: 'first' | 'last'
 *
 * @param config
 * @constructor
 */
class Postgres extends Dialect {
    constructor(config) {
        super(config);
    }
    createSubInstance() {
        return new Postgres(this.config);
    }
    _getParameterValue(value, quoteChar) {
        if ('object' === typeof value && Array.isArray(value)) {
            // naive check to see if this is an array of objects, which
            // is handled differently than an array of primitives
            if (value.length && 'object' === typeof value[0] && !isFunction(value[0].toISOString) && !Array.isArray(value[0])) {
                value = `'${JSON.stringify(value)}'`;
            }
            else {
                // In a Postgres array, strings must be double-quoted
                value = value.map((item) => this._getParameterValue(item, '"'));
                value = `'{${value.join(',')}}'`;
            }
        }
        else if ('object' === typeof value && value instanceof Date) {
            // Date object's default toString format does not get parsed well
            // Handle dates using custom dateToString method for postgres
            value = this._getParameterValue(dateToStringUTC(value), quoteChar);
        }
        else {
            value = super._getParameterValue(value, quoteChar);
        }
        // value has been converted at this point
        return value;
    }
    visitOrderBy(orderByNode) {
        const result = ['ORDER BY', orderByNode.nodes.map(this.visit.bind(this)).join(', ')];
        if (this.config.nullOrder) {
            result.push('NULLS ' + this.config.nullOrder.toUpperCase());
        }
        return result;
    }
}

class Sqlite extends Dialect {
    constructor(config) {
        super(config);
        this.hasAddedAColumn = false;
        this.config = config;
        this.arrayAggFunctionName = 'GROUP_CONCAT';
    }
    createSubInstance() {
        return new Sqlite(this.config);
    }
    _getParameterValue(value, quoteChar) {
        if (Buffer.isBuffer(value)) {
            value = 'x' + this._getParameterValue(value.toString('hex'), quoteChar);
        }
        else if (value instanceof Date && this.config.dateTimeMillis) {
            value = value.getTime();
        }
        else if ('boolean' === typeof value) {
            value = value ? 1 : 0;
        }
        else if (isArray(value)) {
            value = super._getParameterValue(JSON.stringify(value), quoteChar);
        }
        else {
            value = super._getParameterValue(value, quoteChar);
        }
        return value;
    }
    visitReplace(replaceNode) {
        // don't use table.column for replaces
        this.visitedReplace = true;
        let result = ['REPLACE'];
        result = result.concat(replaceNode.nodes.map((n) => this.visit(n).join()));
        result.push('INTO ' + this.visit(this.queryNode.table.toNode()));
        result.push('(' + replaceNode.columns.map(this.visit.bind(this)).join(', ') + ')');
        const paramNodes = replaceNode.getParameters();
        if (paramNodes.length > 0) {
            const paramText = paramNodes
                .map((paramSet) => {
                return paramSet.map((param) => this.visit(param)).join(', ');
            })
                .map((param) => `(${param})`)
                .join(', ');
            result.push('VALUES', paramText);
            if (result.slice(2, 5).join(' ') === '() VALUES ()') {
                result.splice(2, 3, 'DEFAULT VALUES');
            }
        }
        this.visitedReplace = false;
        return result;
    }
    visitDefault(defaultNode) {
        throw new Error('SQLite requires that all rows of a multi-row insert are for the same columns.');
    }
    visitDropColumn(dropColumnNode) {
        throw new Error('SQLite does not allow dropping columns.');
    }
    visitFunctionCall(functionCallNode) {
        this.visitingFunctionCall = true;
        const left = () => {
            // convert LEFT(column,4) to SUBSTR(column,1,4)
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 2) {
                throw new Error('Not enough parameters passed to LEFT function.');
            }
            return `SUBSTR(${nodes[0] + ''}, 1, ${nodes[1] + ''})`;
        };
        const right = () => {
            // convert RIGHT(column,4) to SUBSTR(column,-4)
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 2) {
                throw new Error('Not enough parameters passed to RIGHT function.');
            }
            return `SUBSTR(${nodes[0] + ''}, -${nodes[1] + ''})`;
        };
        const extract = () => {
            const nodes = functionCallNode.nodes.map(this.visit.bind(this));
            if (nodes.length !== 1) {
                throw new Error(`Not enough parameters passed to ${functionCallNode.name} function`);
            }
            let format;
            switch (functionCallNode.name) {
                case 'YEAR':
                    format = "'%Y'";
                    break;
                case 'MONTH':
                    format = "'%m'";
                    break;
                case 'DAY':
                    format = "'%d'";
                    break;
                case 'HOUR':
                    format = "'%H'";
                    break;
            }
            let col = nodes[0] + '';
            if (this.config.dateTimeMillis) {
                // Convert to a datetime before running the strftime function
                // Sqlite unix epoch is in seconds, but javascript is milliseconds.
                col = `datetime(${col}/1000, "unixepoch")`;
            }
            return `strftime(${format}, ${col})`;
        };
        let txt = '';
        const name = functionCallNode.name;
        // Override LEFT and RIGHT and convert to SUBSTR
        if (name === 'LEFT') {
            txt = left();
        }
        else if (name === 'RIGHT') {
            txt = right();
        }
        // Override date functions since sqlite uses strftime
        else if (['YEAR', 'MONTH', 'DAY', 'HOUR'].indexOf(functionCallNode.name) >= 0) {
            txt = extract();
        }
        else if ('CURRENT_TIMESTAMP' === functionCallNode.name) {
            txt = functionCallNode.name;
        }
        else {
            txt = `${name}(${functionCallNode.nodes.map(this.visit.bind(this)).join(', ')})`;
        }
        this.visitingFunctionCall = false;
        return [txt];
    }
    visitTruncate(truncateNode) {
        const result = ['DELETE FROM'];
        return result.concat(truncateNode.nodes.map((n) => this.visit(n).join()));
    }
    visitRenameColumn(renameColumnNode) {
        throw new Error('SQLite does not allow renaming columns.');
    }
    visitOnDuplicate(onDuplicateNode) {
        throw new Error('SQLite does not allow onDuplicate clause.');
    }
    visitOnConflict(onConflictNode) {
        throw new Error('Sqlite does not allow onConflict clause.');
    }
    visitReturning(returningNode) {
        throw new Error('SQLite does not allow returning clause.');
    }
    visitForUpdate(forUpdateNode) {
        throw new Error('SQLite does not allow FOR UPDATE clause.');
    }
    visitForShare(forShareNode) {
        throw new Error('SQLite does not allow FOR SHARE clause.');
    }
    visitAddColumn(addColumnNode) {
        assert(!this.hasAddedAColumn, 'SQLite can not add more that one column at a time');
        const result = super.visitAddColumn.call(this, addColumnNode);
        this.hasAddedAColumn = true;
        return result;
    }
    visitIndexes(indexesNode) {
        const tableName = this.visit(this.queryNode.table.toNode())[0];
        return [`PRAGMA INDEX_LIST(${tableName})`];
    }
    visitCreateIndex(createIndexNode) {
        const { indexType, ifNotExists, indexName, tableName, algorithm, columns, parser } = this._visitCreateIndex(createIndexNode);
        return [
            'CREATE',
            indexType,
            'INDEX',
            ...ifNotExists,
            indexName,
            algorithm,
            'ON',
            ...tableName,
            columns,
            parser
        ].filter(this.notEmpty);
    }
    visitCascade(cascadeNode) {
        throw new Error('Sqlite do not support CASCADE in DROP TABLE');
    }
    visitRestrict(restrictNode) {
        throw new Error('Sqlite do not support RESTRICT in DROP TABLE');
    }
    visitBinary(binaryNode) {
        if (binaryNode.operator === '@@') {
            binaryNode.operator = 'MATCH';
            const ret = super.visitBinary(binaryNode);
            binaryNode.operator = '@@';
            return ret;
        }
        return super.visitBinary(binaryNode);
    }
    visitOrIgnore(orIgnoreNode) {
        return ['OR IGNORE'];
    }
}

registerDialect('mssql', Mssql);
registerDialect('mysql', Mysql);
registerDialect('oracle', Oracle);
registerDialect('postgres', Postgres);
registerDialect('sqlite', Sqlite);

export { AddColumnNode, AliasMixin, AliasNode, AlterNode, ArrayCallNode, AtNode, BinaryNode, CascadeNode, CaseNode, CastNode, Column, ColumnNode, CreateIndexNode, CreateNode, CreateViewNode, DEFAULT_DIALECT, DefaultNode, DeleteNode, Dialect, DistinctNode, DistinctOnNode, DropColumnNode, DropIndexNode, DropNode, ForShareNode, ForUpdateNode, ForeignKeyNode, FromNode, FunctionCallNode, GroupByNode, HavingNode, IfExistsNode, IfNotExistsNode, InNode, IndexesNode, InsertNode, IntervalNode, JoinNode, LiteralNode, ModifierNode, Mssql, Mysql, Node, NotInNode, OnConflictNode, OnDuplicateNode, OrIgnoreNode, Oracle, OrderByNode, OrderByValueNode, ParameterNode, PostfixUnaryNode, Postgres, PrefixUnaryNode, Query, RenameColumnNode, RenameNode, ReplaceNode, RestrictNode, ReturningNode, RowCallNode, SelectNode, SliceNode, Sql, Sqlite, Table, TableNode, TernaryNode, TruncateNode, UpdateNode, WhereNode, getDialect, registerDialect };
//# sourceMappingURL=lib.js.map
