'use strict';
import map from 'lodash/map';
import fromPairs from 'lodash/fromPairs';
import { Column } from './column';
import { leftJoin } from './joiner';
import { ForeignKeyNode, JoinNode, Query, TableNode } from './node';
import { Sql } from './sql';
export class Table {
    constructor(config) {
        this.schema = config.schema;
        this.tableName = config.name;
        this.initialConfig = config;
        this.columnWhiteList = !!config.columnWhiteList;
        this.isTemporary = !!config.isTemporary;
        this.snakeToCamel = !!config.snakeToCamel;
        this.columns = [];
        this.foreignKeys = [];
        this.table = this;
        if (!config.sql) {
            config.sql = new Sql();
        }
        this.sql = config.sql;
        this.engine = config.engine;
        this.charset = config.charset;
    }
    get nodes() {
        return this.select(this.star()).nodes;
    }
    static define(config) {
        const table = new Table(config);
        // allow hash of columns as well as array
        if (config.columns && !Array.isArray(config.columns)) {
            const cols = [];
            for (const key in config.columns) {
                if (config.columns.hasOwnProperty(key)) {
                    const col = config.columns[key];
                    col.name = key;
                    cols.push(col);
                }
            }
            config.columns = cols;
        }
        for (const col of config.columns) {
            table.addColumn(col);
        }
        if (config.foreignKeys !== undefined) {
            if (Array.isArray(config.foreignKeys)) {
                for (const key of config.foreignKeys) {
                    table.foreignKeys.push(new ForeignKeyNode(key));
                }
            }
            else {
                table.foreignKeys.push(new ForeignKeyNode(config.foreignKeys));
            }
        }
        return table;
    }
    clone(config) {
        return Table.define(Object.assign({ columnWhiteList: !!this.columnWhiteList, columns: this.columns, foreignKeys: this.foreignKeys, name: this.tableName, schema: this.schema, snakeToCamel: !!this.snakeToCamel, sql: this.sql }, (config || {})));
    }
    createColumn(col) {
        if (!(col instanceof Column)) {
            if (typeof col === 'string') {
                // tslint:disable-next-line:no-object-literal-type-assertion
                col = { name: col };
            }
            const column = new Column(Object.assign(Object.assign({}, col), { table: this }));
            // Load subfields from array into an object of form name: Column
            if (Array.isArray(col.subfields)) {
                column.subfields = fromPairs(map(col.subfields, (subfield) => {
                    return [
                        subfield,
                        new Column({
                            name: subfield,
                            subfieldContainer: column,
                            table: this
                        })
                    ];
                }));
            }
            return column;
        }
        return col;
    }
    addColumn(col, options) {
        const column = this.createColumn(col);
        options = Object.assign({ noisy: true }, options);
        if (this.hasColumn(column)) {
            if (options.noisy) {
                throw new Error(`Table ${this.tableName} already has column or property by the name of ${column.name}`);
            }
            else {
                return this;
            }
        }
        else if (!!this[column.name] && process.env.NODE_ENV === 'debug') {
            // tslint:disable-next-line:no-console
            console.log(`Please notice that you have just defined the column "${column.name}". In order to access it, you need to use "table.getColumn('${column.name}');"!`);
        }
        this.columns.push(column);
        const snakeToCamel = (snakeName) => {
            return snakeName.replace(/[\-_]([a-z])/g, (m, $1) => $1.toUpperCase());
        };
        const property = (column.property = column.property || (this.snakeToCamel ? snakeToCamel(column.name) : column.name));
        this[property] = this[property] || column;
        return this;
    }
    hasColumn(col) {
        const columnName = col instanceof Column ? col.name : col;
        return this.columns.some((column) => column.property === columnName || column.name === columnName);
    }
    getColumn(colName) {
        for (const col of this.columns) {
            if (colName === col.property || colName === col.name) {
                return col;
            }
        }
        if (this.columnWhiteList) {
            return null;
        }
        throw new Error(`Table ${this.tableName} does not have a column or property named ${colName}`);
    }
    get(colName) {
        return this.getColumn(colName);
    }
    getSchema() {
        return this.schema;
    }
    setSchema(schema) {
        this.schema = schema;
    }
    getName() {
        if (this.sql && this.sql.dialectName === 'mssql' && this.isTemporary) {
            return `#${this.tableName}`;
        }
        return this.tableName;
    }
    star(options) {
        options = options || {};
        if ('prefix' in options) {
            return this.columns.map((column) => column.as(options.prefix + column.name));
        }
        return new Column({ table: this, star: true });
    }
    count(alias) {
        const name = this.alias || this.tableName;
        const col = new Column({ table: this, star: true });
        // ColumnNode
        return col.count(alias || name + '_count');
    }
    select(...args) {
        // create the query and pass it off
        const query = new Query(this);
        if (args.length === 0) {
            query.select(this.star());
        }
        else {
            query.select(...args);
        }
        return query;
    }
    subQuery(alias) {
        // create the query and pass it off
        const query = new Query(this, true);
        query.columns = [];
        query.alias = alias;
        query.join = function (other) {
            return new JoinNode('INNER', this.toNode(), other.toNode());
        };
        return query;
    }
    insert(...nodes) {
        const query = new Query(this);
        if (!nodes[0] || (Array.isArray(nodes[0]) && nodes[0].length === 0)) {
            query.select(this.star());
            query.where('1=2');
        }
        else {
            query.insert(...nodes);
        }
        return query;
    }
    replace(...nodes) {
        const query = new Query(this);
        if (!nodes[0] || (Array.isArray(nodes[0]) && nodes[0].length === 0)) {
            query.select(this.star());
            query.where('1=2');
        }
        else {
            query.replace(...nodes);
        }
        return query;
    }
    toNode() {
        return new TableNode(this);
    }
    join(other) {
        return new JoinNode('INNER', this.toNode(), other.toNode());
    }
    leftJoin(other) {
        return new JoinNode('LEFT', this.toNode(), other.toNode());
    }
    // auto-join tables based on column intropsection
    joinTo(other) {
        return leftJoin(this, other);
    }
    as(alias) {
        // TODO could this be cleaner?
        const t = Table.define(this.initialConfig);
        t.alias = alias;
        return t;
    }
    and(...args) {
        const query = new Query(this);
        query.where(...args);
        return query;
    }
    indexes() {
        return new Query(this).indexes();
    }
    alter() {
        const query = new Query(this);
        query.alter();
        return query;
    }
    create() {
        const query = new Query(this);
        query.create();
        return query;
    }
    delete(arg) {
        const query = new Query(this);
        query.delete(arg);
        return query;
    }
    drop() {
        const query = new Query(this);
        query.drop();
        return query;
    }
    from(...args) {
        const query = new Query(this);
        query.from(...args);
        return query;
    }
    limit(count) {
        const query = new Query(this);
        query.limit(count);
        return query;
    }
    offset(count) {
        const query = new Query(this);
        query.offset(count);
        return query;
    }
    or(object) {
        const query = new Query(this);
        query.or(object);
        return query;
    }
    order(...args) {
        const query = new Query(this);
        query.order(...args);
        return query;
    }
    truncate() {
        const query = new Query(this);
        query.truncate();
        return query;
    }
    update(object) {
        const query = new Query(this);
        query.update(object);
        return query;
    }
    where(...args) {
        const query = new Query(this);
        query.where(...args);
        return query;
    }
}
//# sourceMappingURL=table.js.map