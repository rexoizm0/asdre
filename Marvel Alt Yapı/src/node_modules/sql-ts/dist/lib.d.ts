/// <reference types="node" />
interface INodeable {
    toNode(): Node;
}
declare type PartialNodeable<T> = {
    [P in keyof T]?: T[P] | INodeable | Buffer | null;
};

declare class AliasNode extends Node {
    value: Node;
    alias: string;
    constructor(value: Node, alias: string);
}
declare const AliasMixin: {
    as(this: Node, alias: string): AliasNode;
};

declare const ValueExpressionBaseNode: (abstract new (...args: any[]) => {
    in(val: any): InNode;
    notIn(val: any): NotInNode;
    at(index: any): AtNode;
    slice(start: number, end: number): SliceNode;
    cast(dataType: string): CastNode;
    case(whenList: any[], thenList: any[], elseBranch?: any): CaseNode;
    isNull: (this: INodeable) => PostfixUnaryNode;
    isNotNull: (this: INodeable) => PostfixUnaryNode;
    equals: (this: INodeable, val: any) => BinaryNode;
    notEquals: (this: INodeable, val: any) => BinaryNode;
    gt: (this: INodeable, val: any) => BinaryNode;
    gte: (this: INodeable, val: any) => BinaryNode;
    lt: (this: INodeable, val: any) => BinaryNode;
    lte: (this: INodeable, val: any) => BinaryNode;
    plus: (this: INodeable, val: any) => BinaryNode;
    minus: (this: INodeable, val: any) => BinaryNode;
    multiply: (this: INodeable, val: any) => BinaryNode;
    divide: (this: INodeable, val: any) => BinaryNode;
    modulo: (this: INodeable, val: any) => BinaryNode;
    leftShift: (this: INodeable, val: any) => BinaryNode;
    rightShift: (this: INodeable, val: any) => BinaryNode;
    bitwiseAnd: (this: INodeable, val: any) => BinaryNode;
    bitwiseNot: (this: INodeable, val: any) => BinaryNode;
    bitwiseOr: (this: INodeable, val: any) => BinaryNode;
    bitwiseXor: (this: INodeable, val: any) => BinaryNode;
    regex: (this: INodeable, val: any) => BinaryNode;
    iregex: (this: INodeable, val: any) => BinaryNode;
    regexp: (this: INodeable, val: any) => BinaryNode;
    notRegex: (this: INodeable, val: any) => BinaryNode;
    notIregex: (this: INodeable, val: any) => BinaryNode;
    concat: (this: INodeable, val: any) => BinaryNode;
    key: (this: INodeable, val: any) => BinaryNode;
    keyText: (this: INodeable, val: any) => BinaryNode;
    path: (this: INodeable, val: any) => BinaryNode;
    pathText: (this: INodeable, val: any) => BinaryNode;
    like: (this: INodeable, val: any) => BinaryNode;
    rlike: (this: INodeable, val: any) => BinaryNode;
    notLike: (this: INodeable, val: any) => BinaryNode;
    ilike: (this: INodeable, val: any) => BinaryNode;
    notIlike: (this: INodeable, val: any) => BinaryNode;
    match: (this: INodeable, val: any) => BinaryNode;
    between: (this: INodeable, middle: any, right: any) => TernaryNode;
    notBetween: (this: INodeable, middle: any, right: any) => TernaryNode;
    contains: (this: INodeable, val: any) => BinaryNode;
    containedBy: (this: INodeable, val: any) => BinaryNode;
    containsKey: (this: INodeable, val: any) => BinaryNode;
    overlap: (this: INodeable, val: any) => BinaryNode;
    descending: (this: INodeable) => OrderByValueNode;
    toNode(): Node;
}) & typeof Node;
declare const ValueExpressionNode: (abstract new (...args: any[]) => {
    or: (this: INodeable, val: any) => BinaryNode;
    and: (this: INodeable, val: any) => BinaryNode;
    in(val: any): InNode;
    notIn(val: any): NotInNode;
    at(index: any): AtNode;
    slice(start: number, end: number): SliceNode;
    cast(dataType: string): CastNode;
    case(whenList: any[], thenList: any[], elseBranch?: any): CaseNode;
    isNull: (this: INodeable) => PostfixUnaryNode;
    isNotNull: (this: INodeable) => PostfixUnaryNode;
    equals: (this: INodeable, val: any) => BinaryNode;
    notEquals: (this: INodeable, val: any) => BinaryNode;
    gt: (this: INodeable, val: any) => BinaryNode;
    gte: (this: INodeable, val: any) => BinaryNode;
    lt: (this: INodeable, val: any) => BinaryNode;
    lte: (this: INodeable, val: any) => BinaryNode;
    plus: (this: INodeable, val: any) => BinaryNode;
    minus: (this: INodeable, val: any) => BinaryNode;
    multiply: (this: INodeable, val: any) => BinaryNode;
    divide: (this: INodeable, val: any) => BinaryNode;
    modulo: (this: INodeable, val: any) => BinaryNode;
    leftShift: (this: INodeable, val: any) => BinaryNode;
    rightShift: (this: INodeable, val: any) => BinaryNode;
    bitwiseAnd: (this: INodeable, val: any) => BinaryNode;
    bitwiseNot: (this: INodeable, val: any) => BinaryNode;
    bitwiseOr: (this: INodeable, val: any) => BinaryNode;
    bitwiseXor: (this: INodeable, val: any) => BinaryNode;
    regex: (this: INodeable, val: any) => BinaryNode;
    iregex: (this: INodeable, val: any) => BinaryNode;
    regexp: (this: INodeable, val: any) => BinaryNode;
    notRegex: (this: INodeable, val: any) => BinaryNode;
    notIregex: (this: INodeable, val: any) => BinaryNode;
    concat: (this: INodeable, val: any) => BinaryNode;
    key: (this: INodeable, val: any) => BinaryNode;
    keyText: (this: INodeable, val: any) => BinaryNode;
    path: (this: INodeable, val: any) => BinaryNode;
    pathText: (this: INodeable, val: any) => BinaryNode;
    like: (this: INodeable, val: any) => BinaryNode;
    rlike: (this: INodeable, val: any) => BinaryNode;
    notLike: (this: INodeable, val: any) => BinaryNode;
    ilike: (this: INodeable, val: any) => BinaryNode;
    notIlike: (this: INodeable, val: any) => BinaryNode;
    match: (this: INodeable, val: any) => BinaryNode;
    between: (this: INodeable, middle: any, right: any) => TernaryNode;
    notBetween: (this: INodeable, middle: any, right: any) => TernaryNode;
    contains: (this: INodeable, val: any) => BinaryNode;
    containedBy: (this: INodeable, val: any) => BinaryNode;
    containsKey: (this: INodeable, val: any) => BinaryNode;
    overlap: (this: INodeable, val: any) => BinaryNode;
    descending: (this: INodeable) => OrderByValueNode;
    toNode(): Node;
}) & typeof Node;

declare class AtNode extends ValueExpressionNode {
    value: Node;
    index: Node;
    constructor(value: Node, index: Node);
    as: (this: Node, alias: string) => AliasNode;
}

declare class BinaryNode extends ValueExpressionNode {
    left: Node;
    operator: string;
    right: Node | Node[];
    constructor(config: {
        left: Node;
        operator: string;
        right: Node | Node[];
    });
    as: (this: Node, alias: string) => AliasNode;
}

declare class CaseNode extends ValueExpressionNode {
    whenList: Node[];
    thenList: Node[];
    else?: Node;
    constructor(config: {
        whenList: Node[];
        thenList: Node[];
        else?: Node;
    });
    as: (this: Node, alias: string) => AliasNode;
}

declare class CastNode extends ValueExpressionNode {
    value: Node;
    dataType: string;
    constructor(value: Node, dataType: string);
    as: (this: Node, alias: string) => AliasNode;
}

declare class InNode extends ValueExpressionNode {
    left: Node;
    right: Node | Node[];
    constructor(config: {
        left: Node;
        right: Node | Node[];
    });
    as: (this: Node, alias: string) => AliasNode;
}

declare class NotInNode extends ValueExpressionNode {
    left: Node;
    right: Node | Node[];
    constructor(config: {
        left: Node;
        right: Node | Node[];
    });
    as: (this: Node, alias: string) => AliasNode;
}

declare class TextNode extends Node {
    text: string;
    constructor(text: string);
}

declare class OrderByValueNode extends Node {
    value: Node;
    direction?: TextNode;
    constructor(config: {
        value: Node;
        direction?: TextNode;
    });
}

declare class PostfixUnaryNode extends ValueExpressionNode {
    left: Node;
    operator: string;
    constructor(config: {
        left: Node;
        operator: string;
    });
    as: (this: Node, alias: string) => AliasNode;
}

declare class SliceNode extends ValueExpressionNode {
    value: Node;
    start: Node;
    end: Node;
    constructor(value: Node, start: Node, end: Node);
    as: (this: Node, alias: string) => AliasNode;
}

declare class TernaryNode extends ValueExpressionNode {
    left: Node;
    middle: Node;
    operator: string;
    right: Node;
    separator: string;
    constructor(config: {
        left: Node;
        middle: Node;
        operator: string;
        right: Node;
        separator: string;
    });
    as: (this: Node, alias: string) => AliasNode;
}

declare type SQLDialects = 'mssql' | 'mysql' | 'oracle' | 'postgres' | 'sqlite';
interface ColumnDefinitionBase {
    property?: string;
    autoGenerated?: boolean;
    dataType?: string;
    primaryKey?: boolean;
    references?: string | {
        table?: string;
        column?: string;
        constraint?: string;
        onDelete?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
        onUpdate?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
    };
    notNull?: boolean;
    unique?: boolean;
    defaultValue?: any;
    subfields?: string[];
}
interface ColumnDefinition extends ColumnDefinitionBase {
    name: string;
}
interface ColumnDefinitionObject {
    [name: string]: ColumnDefinitionBase;
}
interface ForeignKeyDefinition {
    name?: string;
    table: string;
    columns: string[];
    refColumns?: string[];
    onDelete?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
    onUpdate?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
}
interface TableDefinition {
    name: string;
    schema?: string;
    columns: (ColumnDefinition | string)[] | ColumnDefinitionObject;
    isTemporary?: boolean;
    foreignKeys?: ForeignKeyDefinition | ForeignKeyDefinition[];
    sql?: Sql;
    engine?: string;
    charset?: string;
    snakeToCamel?: boolean;
    columnWhiteList?: boolean;
}

declare class DropIndexNode extends Node {
    table: Table<unknown>;
    options: {
        indexName: string;
        ifExists?: boolean;
    };
    constructor(table: Table<unknown>, indexName: string | string[] | Column<unknown>[]);
    ifExists(): DropIndexNode;
}

declare class ForeignKeyNode extends Node {
    name?: string;
    columns: string[];
    schema?: string;
    table: string;
    refColumns?: string[];
    onUpdate?: string;
    onDelete?: string;
    constraint?: string;
    constructor(config: {
        table: string;
        columns: string[];
        refColumns?: string[];
        onDelete?: string;
        onUpdate?: string;
        name?: string;
        schema?: string;
        constraint?: string;
    });
}

declare class JoinNode extends Node {
    subType: string;
    from: Node;
    to: Node;
    onNode: Node;
    constructor(subType: string, from: INodeable, to: INodeable);
    on(node: Node): this;
    join(other: INodeable): JoinNode;
    leftJoin(other: INodeable): JoinNode;
}

declare class CreateIndexNode extends Node implements IndexCreationQuery {
    table: Table<unknown>;
    options: {
        indexName: string;
        columns: Column<unknown>[];
        type?: string;
        algorithm?: string;
        parser?: string;
        ifNotExists?: boolean;
    };
    constructor(table: Table<unknown>, indexName: string);
    unique(): this;
    spatial(): this;
    fulltext(): this;
    using(algorithm: string): this;
    on(...columns: Column<unknown>[]): this;
    withParser(parser: string): this;
    indexName(): string;
    ifNotExists(): this;
}

declare class PrefixUnaryNode extends ValueExpressionNode {
    left: Node;
    operator: string;
    constructor(config: {
        left: Node;
        operator: string;
    });
    as: (this: Node, alias: string) => AliasNode;
}

declare class Query<T> extends ValueExpressionBaseNode {
    table: Table<T>;
    nodes: Node[];
    alias?: string;
    private whereClause?;
    private insertClause?;
    private replaceClause?;
    private indexesClause?;
    private _select?;
    private _orderBy?;
    private _distinctOn?;
    constructor(table: Table<T>, isSubquery?: boolean);
    as: (this: Node, alias: string) => AliasNode;
    select(...args: any[]): this;
    star(): Column<unknown>;
    from(node: INodeable[] | INodeable | string): this;
    from(...nodes: INodeable[]): this;
    leftJoin(other: INodeable): JoinNode;
    where(object: Partial<T> | Node[] | Node | string): this;
    where(...nodes: Node[]): this;
    or(object: Partial<T> | Node | string): this;
    and(object: Partial<T> | Node[] | Node | string): this;
    order(node: INodeable[] | INodeable): this;
    order(...nodes: INodeable[]): this;
    group(node: INodeable[] | INodeable): this;
    group(...nodes: INodeable[]): this;
    having(node: INodeable[] | INodeable): this;
    having(...nodes: INodeable[]): this;
    insert(object: Column<unknown>[] | Column<unknown>): this;
    insert(object: PartialNodeable<T>[] | PartialNodeable<T>): this;
    insert(...nodes: Column<unknown>[]): this;
    replace(object: Column<unknown>[] | Column<unknown>): this;
    replace(object: Partial<T>[] | Partial<T>): this;
    replace(...nodes: Column<unknown>[]): this;
    update(object: PartialNodeable<T>): this;
    parameter(v: any): this;
    delete(table: Table<unknown>[] | Table<unknown> | Partial<T>): this;
    delete(): this;
    returning(...args: any[]): this;
    onDuplicate(object: Partial<T>): this;
    onConflict(options: {
        constraint: string;
        update?: string[];
    } | {
        columns: string[];
        update?: string[];
    }): this;
    forUpdate(): this;
    forShare(): this;
    create(): this;
    create(indexName: string): CreateIndexNode;
    drop(): this;
    drop(indexName: string): DropIndexNode;
    drop(...columns: Column<unknown>[]): DropIndexNode;
    truncate(): this;
    distinct(): this;
    distinctOn(...args: any[]): this;
    alter(): this;
    rename(newName: Column<unknown> | string): this;
    addColumn(column: Column<unknown> | string, dataType?: string): this;
    dropColumn(column: Column<unknown> | string): this;
    renameColumn(oldColumn: Column<unknown> | string, newColumn: Column<unknown> | string): this;
    limit(count: unknown): this;
    offset(count: unknown): this;
    exists(): PrefixUnaryNode;
    notExists(): PrefixUnaryNode;
    ifExists(): this;
    ifNotExists(): this;
    orIgnore(): this;
    cascade(): this;
    restrict(): this;
    indexes(): this;
    createView(viewName: string): this;
}
declare type SubQueryExtensions<T, C extends Record<string, any>> = {
    join: (other: INodeable) => JoinNode;
} & {
    columns: Column<unknown>[];
} & {
    [P in NonNullable<keyof C>]: Column<C[P]>;
};
declare type SubQuery<T, C extends Record<string, any>> = Query<T> & SubQueryExtensions<T, C>;

declare class TableNode extends Node {
    table: Table<unknown>;
    constructor(table: Table<unknown>);
}

declare type TableWithColumns<T> = Table<T> & {
    [Name in NonNullable<keyof T>]: Column<T[Name]>;
};
declare class Table<T> implements INodeable {
    get nodes(): Node[];
    static define<Model>(config: TableDefinition): TableWithColumns<Model>;
    columnWhiteList: boolean;
    isTemporary: boolean;
    snakeToCamel: boolean;
    columns: Column<T[keyof T]>[];
    foreignKeys: ForeignKeyNode[];
    table: this;
    sql: Sql;
    engine?: string;
    charset?: string;
    alias?: string;
    initialConfig: TableDefinition;
    private schema?;
    private tableName;
    constructor(config: TableDefinition);
    clone(config?: Partial<TableDefinition>): TableWithColumns<T>;
    createColumn(col: string | ColumnDefinition | Column<unknown>): Column<unknown>;
    addColumn(col: string | ColumnDefinition | Column<unknown>, options?: any): this;
    hasColumn(col: Column<unknown> | string): boolean;
    getColumn(colName: string): Column<T[keyof T]> | null;
    get(colName: string): Column<T[keyof T]> | null;
    getSchema(): string | undefined;
    setSchema(schema: string): void;
    getName(): string;
    star(): Column<unknown>;
    star(options: {
        prefix: string;
    }): ColumnNode[];
    count(alias?: string): ColumnNode;
    select(...args: any[]): Query<T>;
    subQuery<C extends Record<string, any>>(alias?: string): SubQuery<T, C>;
    insert(object: Column<unknown>[] | Column<unknown>): Query<T>;
    insert(object: PartialNodeable<T>[] | PartialNodeable<T>): Query<T>;
    insert(...nodes: Column<unknown>[]): Query<T>;
    replace(object: Column<unknown>[] | Column<unknown>): Query<T>;
    replace(object: PartialNodeable<T>[] | PartialNodeable<T>): Query<T>;
    replace(...nodes: Column<unknown>[]): Query<T>;
    toNode(): TableNode;
    join(other: INodeable): JoinNode;
    leftJoin(other: INodeable): JoinNode;
    joinTo(other: Table<unknown>): JoinNode;
    as(alias: string): TableWithColumns<T>;
    and(...args: Node[]): Query<T>;
    indexes(): IndexQuery;
    alter(): Query<T>;
    create(): Query<T>;
    delete(table: Table<unknown>[] | Table<unknown> | Table<T> | Partial<T>): Query<T>;
    delete(): Query<T>;
    drop(): Query<T>;
    from(table: Table<unknown>[] | Table<unknown> | Table<T> | JoinNode): Query<T>;
    from(...tables: Table<unknown>[]): Query<T>;
    limit(count: unknown): Query<T>;
    offset(count: unknown): Query<T>;
    or(object: Partial<T> | Node | string): Query<T>;
    order(node: INodeable[] | INodeable): Query<T>;
    order(...nodes: INodeable[]): Query<T>;
    truncate(): Query<T>;
    update(object: PartialNodeable<T>): Query<T>;
    where(object: Partial<T> | Node[] | Node | string): Query<T>;
    where(...nodes: Node[]): Query<T>;
}
interface IndexQuery {
    create(indexName?: string): IndexCreationQuery;
    drop(indexName: string): DropIndexNode;
    drop(...columns: Column<unknown>[]): DropIndexNode;
}
interface IndexCreationQuery extends Node {
    ifNotExists(): IndexCreationQuery;
    unique(): IndexCreationQuery;
    using(name: string): IndexCreationQuery;
    on(...columns: (Column<unknown> | OrderByValueNode)[]): IndexCreationQuery;
    withParser(parserName: string): IndexCreationQuery;
    fulltext(): IndexCreationQuery;
    spatial(): IndexCreationQuery;
}

declare class ColumnNode extends Node {
    name: string;
    property: string;
    alias?: string;
    star?: boolean;
    isConstant?: boolean;
    constantValue?: any;
    asArray?: boolean;
    aggregator?: string;
    table?: Table<unknown>;
    value: any;
    dataType?: string;
    isDistinct?: boolean;
    primaryKey?: boolean;
    notNull?: boolean;
    defaultValue?: any;
    references?: string | {
        table?: string;
        column?: string;
        constraint?: string;
        onDelete?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
        onUpdate?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
    };
    subfieldContainer?: Column<unknown>;
    subfields: {
        [key: string]: Column<unknown>;
    };
    autoGenerated: boolean;
    unique: boolean;
    constructor(config: Column<unknown>);
    distinct(): this;
    as(alias: string): this;
}

interface ColumnConfig {
    name?: string;
    property?: string;
    autoGenerated?: boolean;
    jsType?: any;
    dataType?: string;
    primaryKey?: boolean;
    references?: string | {
        table?: string;
        column?: string;
        constraint?: string;
        onDelete?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
        onUpdate?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
    };
    notNull?: boolean;
    unique?: boolean;
    defaultValue?: any;
    subfields?: string[];
    table?: Table<unknown>;
    star?: boolean;
    subfieldContainer?: Column<unknown>;
    isConstant?: boolean;
    constantValue?: any;
}
declare abstract class ColumnBase implements INodeable {
    abstract toNode(): Node;
}
declare const Column_base: (abstract new (...args: any[]) => {
    or: (this: INodeable, val: any) => BinaryNode;
    and: (this: INodeable, val: any) => BinaryNode;
    in(val: any): InNode;
    notIn(val: any): NotInNode;
    at(index: any): AtNode;
    slice(start: number, end: number): SliceNode;
    cast(dataType: string): CastNode;
    case(whenList: any[], thenList: any[], elseBranch?: any): CaseNode;
    isNull: (this: INodeable) => PostfixUnaryNode;
    isNotNull: (this: INodeable) => PostfixUnaryNode;
    equals: (this: INodeable, val: any) => BinaryNode;
    notEquals: (this: INodeable, val: any) => BinaryNode;
    gt: (this: INodeable, val: any) => BinaryNode;
    gte: (this: INodeable, val: any) => BinaryNode;
    lt: (this: INodeable, val: any) => BinaryNode;
    lte: (this: INodeable, val: any) => BinaryNode;
    plus: (this: INodeable, val: any) => BinaryNode;
    minus: (this: INodeable, val: any) => BinaryNode;
    multiply: (this: INodeable, val: any) => BinaryNode;
    divide: (this: INodeable, val: any) => BinaryNode;
    modulo: (this: INodeable, val: any) => BinaryNode;
    leftShift: (this: INodeable, val: any) => BinaryNode;
    rightShift: (this: INodeable, val: any) => BinaryNode;
    bitwiseAnd: (this: INodeable, val: any) => BinaryNode;
    bitwiseNot: (this: INodeable, val: any) => BinaryNode;
    bitwiseOr: (this: INodeable, val: any) => BinaryNode;
    bitwiseXor: (this: INodeable, val: any) => BinaryNode;
    regex: (this: INodeable, val: any) => BinaryNode;
    iregex: (this: INodeable, val: any) => BinaryNode;
    regexp: (this: INodeable, val: any) => BinaryNode;
    notRegex: (this: INodeable, val: any) => BinaryNode;
    notIregex: (this: INodeable, val: any) => BinaryNode;
    concat: (this: INodeable, val: any) => BinaryNode;
    key: (this: INodeable, val: any) => BinaryNode;
    keyText: (this: INodeable, val: any) => BinaryNode;
    path: (this: INodeable, val: any) => BinaryNode;
    pathText: (this: INodeable, val: any) => BinaryNode;
    like: (this: INodeable, val: any) => BinaryNode;
    rlike: (this: INodeable, val: any) => BinaryNode;
    notLike: (this: INodeable, val: any) => BinaryNode;
    ilike: (this: INodeable, val: any) => BinaryNode;
    notIlike: (this: INodeable, val: any) => BinaryNode;
    match: (this: INodeable, val: any) => BinaryNode;
    between: (this: INodeable, middle: any, right: any) => TernaryNode;
    notBetween: (this: INodeable, middle: any, right: any) => TernaryNode;
    contains: (this: INodeable, val: any) => BinaryNode;
    containedBy: (this: INodeable, val: any) => BinaryNode;
    containsKey: (this: INodeable, val: any) => BinaryNode;
    overlap: (this: INodeable, val: any) => BinaryNode;
    descending: (this: INodeable) => OrderByValueNode;
    toNode(): Node;
}) & typeof ColumnBase;
declare class Column<T> extends Column_base implements INodeable {
    name: string;
    property?: string;
    table?: Table<unknown>;
    alias?: string;
    dataType?: string;
    _value: any;
    star?: boolean;
    subfields: {
        [key: string]: Column<unknown>;
    };
    asArray?: boolean;
    aggregator?: string;
    isConstant?: boolean;
    constantValue?: any;
    primaryKey?: boolean;
    notNull?: boolean;
    defaultValue?: any;
    references?: string | {
        table?: string;
        column?: string;
        constraint?: string;
        onDelete?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
        onUpdate?: 'restrict' | 'cascade' | 'no action' | 'set null' | 'set default';
    };
    subfieldContainer?: Column<unknown>;
    autoGenerated?: boolean;
    unique?: boolean;
    isDistinct?: boolean;
    constructor(config: ColumnConfig);
    value(value: any): Column<T>;
    getValue(): any;
    toNode(): ColumnNode;
    as(alias: string): ColumnNode;
    asc(): OrderByValueNode;
    desc(): OrderByValueNode;
    arrayAgg(alias?: string): ColumnNode;
    aggregate(alias: string | undefined, aggregator: string): ColumnNode;
    count(alias?: string): ColumnNode;
    min(alias?: string): ColumnNode;
    max(alias?: string): ColumnNode;
    sum(alias?: string): ColumnNode;
    avg(alias?: string): ColumnNode;
    distinct(): ColumnNode;
    toQuery(): {
        text: string;
        values: string[];
    };
}

declare class FunctionCallNode extends ValueExpressionNode {
    name: string;
    constructor(name: string, args: any[]);
    as: (this: Node, alias: string) => AliasNode;
}

declare const standardFunctionNames: readonly ["AVG", "COUNT", "DISTINCT", "MAX", "MIN", "SUM", "ABS", "COALESCE", "LEFT", "LENGTH", "LOWER", "LTRIM", "RANDOM", "RIGHT", "ROUND", "RTRIM", "SUBSTR", "TRIM", "UPPER", "HSTORE", "TS_RANK", "TS_RANK_CD", "PLAINTO_TSQUERY", "TO_TSQUERY", "TO_TSVECTOR", "SETWEIGHT", "YEAR", "MONTH", "DAY", "HOUR", "CURRENT_TIMESTAMP", "JSONB_ARRAY_LENGTH", "JSONB_BUILD_ARRAY", "JSONB_BUILD_OBECT", "JSONB_EXTRACT_PATH", "JSONB_INSERT", "JSONB_OBJECT", "JSONB_PRETTY", "JSONB_SET", "JSONB_STRIP_NULLS", "JSONB_TYPEOF", "TO_JSONB", "JSONB_ARRAY_ELEMENTS", "JSONB_ARRAY_ELEMENTS_TEXT", "JSONB_EACH", "JSONB_EACH_TEXT", "JSONB_OBJECT_KEYS", "JSONB_AGG"];
declare type StandardFunctions = {
    [K in (typeof standardFunctionNames)[number]]: (...args: any[]) => FunctionCallNode;
};

declare class ArrayCallNode extends ValueExpressionNode {
    constructor(args: any[]);
    as: (this: Node, alias: string) => AliasNode;
}

interface Interval {
    years: number;
    months: number;
    days: number;
    hours: number;
    minutes: number;
    seconds: number;
}
declare class IntervalNode extends Node {
    years: number;
    months: number;
    days: number;
    hours: number;
    minutes: number;
    seconds: number;
    constructor(args: Interval[]);
}

declare class LiteralNode extends Node {
    literal: string;
    alias?: string;
    constructor(literal: string);
    as(alias: string): this;
}

declare class ParameterNode extends Node {
    static getNodeOrParameterNode(value?: INodeable | unknown): Node;
    isExplicit: boolean;
    private val;
    constructor(val: any);
    value(): any;
}

declare class RowCallNode extends ValueExpressionNode {
    constructor(args: any[]);
    as: (this: Node, alias: string) => AliasNode;
}

declare class Sql {
    functions: StandardFunctions;
    dialect: any;
    dialectName: SQLDialects;
    config: any;
    private _function;
    constructor(dialect?: SQLDialects, config?: any);
    function(functionNames: string[]): {
        [key: string]: (...args: any[]) => FunctionCallNode;
    };
    function(functionName: string): (...args: any[]) => FunctionCallNode;
    define<T>(def: TableDefinition): TableWithColumns<T>;
    defineColumn<T>(def: ColumnDefinition): Column<T>;
    array(...args: any[]): ArrayCallNode;
    row(...args: any[]): RowCallNode;
    select(...args: any[]): Query<unknown>;
    interval(...args: any[]): IntervalNode;
    setDialect(dialect: SQLDialects, config?: any): this;
    constant(value: any): Column<unknown>;
    literal(literal: any): LiteralNode;
    parameter(value: any): ParameterNode;
}

declare abstract class Node implements INodeable {
    sql?: Sql;
    readonly type: string;
    nodes: Node[];
    constructor(type: string);
    toNode(): this;
    add(node: Node | INodeable): this;
    unshift(node: Node | INodeable): this;
    toQuery(dialect?: string): {
        text: string;
        values: string[];
    };
    toNamedQuery(name: string, dialect?: string): {
        name: string;
        text: string;
        values: string[];
    };
    toString(dialect?: string): string;
    addAll(nodes: (Node | INodeable)[]): this;
}

declare class ModifierNode extends Node {
    query: Query<unknown>;
    count: Node;
    constructor(query: Query<unknown>, type: 'LIMIT' | 'OFFSET', count: unknown);
}

declare class SelectNode extends Node {
    msSQLLimitNode?: ModifierNode;
    isDistinct: boolean;
    constructor();
}

declare class InsertNode extends Node {
    names: string[];
    columns: ColumnNode[];
    valueSets: {
        [key: string]: ColumnNode;
    }[];
    constructor();
    add(nodes: Column<unknown>[] | Node | INodeable | string): this;
    getParameters(): Node[][];
}

declare class ReplaceNode extends Node {
    columns: ColumnNode[];
    names: string[];
    valueSets: {
        [key: string]: ColumnNode;
    }[];
    constructor();
    add(nodes: Column<unknown>[] | Node | INodeable | string): this;
    getParameters(): Node[][];
}

declare class UpdateNode extends Node {
    constructor();
}

declare class DeleteNode extends Node {
    constructor();
}

declare class CreateNode extends Node {
    options: {
        isTemporary: boolean;
    };
    constructor(isTemporary: boolean);
}

declare class DropNode extends Node {
    constructor(table: Table<unknown>);
}

declare class TruncateNode extends Node {
    constructor(table: Table<unknown>);
}

declare class DistinctNode extends Node {
    constructor();
}

declare class DistinctOnNode extends Node {
    constructor();
}

declare class AlterNode extends Node {
    constructor();
}

declare class FromNode extends Node {
    skipFromStatement: boolean;
    constructor();
}

declare class WhereNode extends Node {
    table: Table<unknown>;
    constructor(table: Table<unknown>);
    add(node: Node[] | Node | INodeable | Record<string, any> | string): this;
    or(other: Node | Record<string, any> | string): void;
    and(other: Node[] | Node | Record<string, any> | string): void;
}

declare class OrderByNode extends Node {
    msSQLOffsetNode?: ModifierNode;
    msSQLLimitNode?: ModifierNode;
    constructor();
}

declare class GroupByNode extends Node {
    constructor();
}

declare class HavingNode extends Node {
    constructor();
}

declare class DefaultNode extends Node {
    constructor();
}

declare class AddColumnNode extends Node {
    constructor();
}

declare class DropColumnNode extends Node {
    constructor();
}

declare class RenameColumnNode extends Node {
    constructor();
}

declare class RenameNode extends Node {
    constructor();
}

declare class IfExistsNode extends Node {
    constructor();
}

declare class IfNotExistsNode extends Node {
    constructor();
}

declare class OrIgnoreNode extends Node {
    constructor();
}

declare class CascadeNode extends Node {
    constructor();
}

declare class RestrictNode extends Node {
    constructor();
}

declare class ForUpdateNode extends Node {
    constructor();
}

declare class ForShareNode extends Node {
    constructor();
}

declare class ReturningNode extends Node {
    constructor();
}

declare class OnDuplicateNode extends Node {
    constructor();
}

declare class OnConflictNode extends Node {
    columns?: string[];
    constraint?: string;
    update?: string[];
    constructor(config: {
        columns?: string[];
        constraint?: string;
        update?: string[];
    });
}

declare class IndexesNode extends Node {
    table: Table<unknown>;
    constructor(table: Table<unknown>);
}

declare class CreateViewNode extends Node {
    options: {
        viewName: string;
    };
    constructor(viewName: string);
}

declare abstract class Dialect<ConfigType> {
    protected config: ConfigType;
    protected output: string[];
    protected params: string[];
    protected queryNode?: Query<unknown>;
    protected arrayAggFunctionName: string;
    protected aliasText: string;
    protected quoteCharacter: string;
    protected disableParameterPlaceholders: boolean;
    protected selectOrDeleteEndIndex: number;
    protected visitedInsert: boolean;
    protected visitingUpdateTargetColumn: boolean;
    protected visitingCreate: boolean;
    protected visitCreateCompoundPrimaryKey: boolean;
    protected visitingAlter: boolean;
    protected visitingCast: boolean;
    protected visitingWhere: boolean;
    protected visitingCase: boolean;
    protected visitedReplace: boolean;
    protected visitingAddColumn: boolean;
    protected visitingReturning: boolean;
    protected visitingJoin: boolean;
    protected visitingFunctionCall: boolean;
    constructor(config: ConfigType);
    protected abstract createSubInstance(): Dialect<ConfigType>;
    _getParameterText(index: number, value: any): string;
    _getParameterValue(value: null | boolean | number | string | any[] | Date | Buffer | Record<string, any>, quoteChar?: string): string | number;
    _getParameterPlaceholder(index: string | number, value: unknown): string;
    getQuery(queryNode: Query<unknown> | Table<unknown>): {
        text: string;
        values: string[];
    };
    getString(queryNode: Query<unknown>): string;
    visit(node: Node): string[];
    quote(word: string, quoteCharacter?: string): string;
    visitSelect(selectNode: SelectNode): string[];
    visitInsert(insertNode: InsertNode): string[];
    visitReplace(replaceNode: ReplaceNode): string[];
    visitUpdate(updateNode: UpdateNode): string[];
    visitDelete(deleteNode: DeleteNode): string[];
    visitCreate(createNode: CreateNode): string[];
    visitDrop(dropNode: DropNode): string[];
    visitTruncate(truncateNode: TruncateNode): string[];
    visitDistinct(distinctNode: DistinctNode): string[];
    visitDistinctOn(distinctOnNode: DistinctOnNode): string[];
    visitAlias(aliasNode: AliasNode): string[];
    visitAlter(alterNode: AlterNode): string[];
    visitCast(castNode: CastNode): string[];
    visitFrom(fromNode: FromNode): string[];
    visitWhere(whereNode: WhereNode): string[];
    visitOrderBy(orderByNode: OrderByNode): string[];
    visitOrderByValue(orderByValueNode: OrderByValueNode): string[];
    visitGroupBy(groupByNode: GroupByNode): string[];
    visitHaving(havingNode: HavingNode): string[];
    visitPrefixUnary(prefixUnaryNode: PrefixUnaryNode): string[];
    visitPostfixUnary(postfixUnaryNode: PostfixUnaryNode): string[];
    visitBinary(binaryNode: BinaryNode): string[];
    visitTernary(ternaryNode: TernaryNode): string[];
    visitIn(inNode: InNode): string[];
    visitNotIn(notInNode: NotInNode): string[];
    visitCase(caseNode: CaseNode): string[];
    visitAt(atNode: AtNode): string[];
    visitSlice(sliceNode: SliceNode): string[];
    visitQuery(queryNode: Query<unknown>): string[];
    /**
     * We separate out this part of query building so it can be overridden by other implementations.
     *
     * @param {Node[]} actions
     * @param {Node[]} targets
     * @param {Node[]} filters
     * @returns {String[]}
     */
    visitQueryHelper(actions: Node[], targets: Node[], filters: Node[]): string[];
    visitSubquery(queryNode: Query<unknown>, dontParenthesize?: boolean): string[];
    visitTable(tableNode: TableNode): string[];
    visitColumn(columnNode: ColumnNode): string[];
    visitForeignKey(foreignKeyNode: ForeignKeyNode): string[];
    visitFunctionCall(functionCallNode: FunctionCallNode): string[];
    visitArrayCall(arrayCallNode: ArrayCallNode): string[];
    visitRowCall(rowCallNode: RowCallNode): string[];
    visitParameter(parameterNode: ParameterNode): string[];
    visitDefault(defaultNode: DefaultNode): string[];
    visitAddColumn(addColumnNode: AddColumnNode): string[];
    visitDropColumn(dropColumnNode: DropColumnNode): string[];
    visitRenameColumn(renameColumnNode: RenameColumnNode): string[];
    visitRename(renameNode: RenameNode): string[];
    visitIfExists(ifExistsNode: IfExistsNode): string[];
    visitIfNotExists(ifNotExistsNode: IfNotExistsNode): string[];
    visitOrIgnore(orIgnoreNode: OrIgnoreNode): string[];
    visitCascade(cascadeNode: CascadeNode): string[];
    visitRestrict(restrictNode: RestrictNode): string[];
    visitForUpdate(forUpdateNode: ForUpdateNode): string[];
    visitForShare(forShareNode: ForShareNode): string[];
    visitJoin(joinNode: JoinNode): string[];
    visitLiteral(literalNode: LiteralNode): string[];
    visitText(textNode: TextNode): string[];
    visitReturning(returningNode: ReturningNode): string[];
    visitOnDuplicate(onDuplicateNode: OnDuplicateNode): string[];
    visitOnConflict(onConflictNode: OnConflictNode): string[];
    visitModifier(modifierNode: ModifierNode): string[];
    visitIndexes(indexesNode: IndexesNode): string[];
    protected notEmpty<T>(t: T | undefined): t is T;
    protected _visitCreateIndex(createIndexNode: CreateIndexNode): {
        indexType: string | undefined;
        ifNotExists: string[];
        indexName: string;
        tableName: string[];
        algorithm: string | undefined;
        columns: string;
        parser: string | undefined;
    };
    visitCreateIndex(createIndexNode: CreateIndexNode): string[];
    visitIfNotExistsIndex(): string[];
    visitDropIndex(dropIndexNode: DropIndexNode): string[];
    visitIfExistsIndex(): string[];
    visitCreateView(createViewNode: CreateViewNode): string[];
    visitInterval(intervalNode: IntervalNode): string[];
    /**
     * Broken out as a separate function so that dialects that derive from this class can still use this functionality.
     *
     * @param {Node[]} list
     * @param {String} type
     * @returns {Object|undefined} {index:number, node:Node}
     */
    findNode(list: Node[], type: string): {
        index: number;
        node: Node;
    } | undefined;
    /**
     * pulls the DISTINCT node out of the filters and flags the SELECT node that it should be distinct.
     * Broken out as a separate function so that dialects that derive from this class can still use this functionality.
     */
    handleDistinct(actions: Node[], filters: Node[]): void;
}

declare const registerDialect: (dialect: string, ctor: new (...args: any[]) => Dialect<any>) => void;
declare const getDialect: (dialect: string) => new (...args: any[]) => Dialect<any>;
declare const DEFAULT_DIALECT = "postgres";

/**
 * Config can contain:
 *
 * questionMarkParameterPlaceholder:true which will use a "?" for the parameter placeholder instead of the @index.
 *
 * @param config
 * @constructor
 */
declare class Mssql extends Dialect<{
    questionMarkParameterPlaceholder?: boolean;
}> {
    constructor(config: {
        questionMarkParameterPlaceholder?: boolean;
    });
    protected createSubInstance(): Mssql;
    _getParameterPlaceholder(index: string | number, value: any): string;
    visitReplace(replaceNode: ReplaceNode): string[];
    visitBinary(binaryNode: BinaryNode): string[];
    visitAlter(alterNode: AlterNode): string[];
    visitCase(caseNode: CaseNode): string[];
    visitColumn(columnNode: ColumnNode): string[];
    visitCreate(createNode: CreateNode): string[];
    visitDrop(dropNode: DropNode): string[];
    visitFunctionCall(functionCallNode: FunctionCallNode): string[];
    visitOrderBy(orderByNode: OrderByNode): string[];
    /**
     * We override this so that we can deal with the LIMIT and OFFSET clauses specially since they have to become
     * part of the SELECT and ORDER BY clauses.
     *
     * Basically if there's an ORDER BY clause we attach OFFSET and LIMIT to it so that it can be processed by the
     * ORDER BY handler later.
     *
     * If there's a LIMIT clause without OFFSET, we attach it to the SELECT clause so we can process it later.
     *
     * @param {Node[]} actions
     * @param {Node[]} targets
     * @param {Node[]} filters
     * @returns {String[]}
     */
    visitQueryHelper(actions: Node[], targets: Node[], filters: Node[]): string[];
    visitCreateIndex(createIndexNode: CreateIndexNode): string[];
    visitIfNotExistsIndex(): string[];
    visitOnDuplicate(onDuplicateNode: OnDuplicateNode): string[];
    visitOnConflict(onConflictNode: OnConflictNode): string[];
    visitReturning(returningNode: ReturningNode): string[];
    visitSelect(selectNode: SelectNode): string[];
}

declare class Mysql extends Dialect<any> {
    constructor(config: any);
    protected createSubInstance(): Mysql;
    _getParameterPlaceholder(index: string | number, value: any): string;
    _getParameterValue(value: null | boolean | number | string | any[] | Date | Buffer | Record<string, any>, quoteChar?: string): string | number;
    visitReplace(replaceNode: ReplaceNode): string[];
    visitOnDuplicate(onDuplicateNode: OnDuplicateNode): string[];
    visitOnConflict(onConflictNode: OnConflictNode): string[];
    visitReturning(returningNode: ReturningNode): string[];
    visitForShare(forShareNode: ForShareNode): string[];
    visitCreate(createNode: CreateNode): string[];
    visitRenameColumn(renameColumnNode: RenameColumnNode): string[];
    visitInsert(insertNode: InsertNode): string[];
    visitIndexes(indexesNode: IndexesNode): string[];
    visitCreateIndex(createIndexNode: CreateIndexNode): string[];
    visitIfNotExistsIndex(): string[];
    visitIfExistsIndex(): string[];
    visitBinary(binaryNode: BinaryNode): string[];
    visitFunctionCall(functionCallNode: FunctionCallNode): string[];
    visitColumn(columnNode: ColumnNode): string[];
    visitInterval(intervalNode: IntervalNode): string[];
}

declare class Oracle extends Dialect<any> {
    constructor(config: any);
    protected createSubInstance(): Oracle;
    _getParameterValue(value: null | boolean | number | string | any[] | Date | Buffer | Record<string, any>, quoteChar?: string): string | number;
    _getParameterPlaceholder(index: string | number, value: any): string;
    visitReplace(replaceNode: ReplaceNode): string[];
    visitAlias(aliasNode: AliasNode): string[];
    visitAlter(alterNode: AlterNode): string[];
    visitTable(tableNode: TableNode): string[];
    visitCascade(cascadeNode: CascadeNode): string[];
    visitRestrict(restrictNode: RestrictNode): string[];
    visitDrop(dropNode: DropNode): string[];
    visitCreate(createNode: CreateNode): string[];
    visitBinary(binaryNode: BinaryNode): string[];
    visitModifier(modifierNode: ModifierNode): string[];
    visitQueryHelper(actions: Node[], targets: Node[], filters: Node[]): string[];
    visitColumn(columnNode: ColumnNode): string[];
    visitReturning(returningNode: ReturningNode): string[];
    visitIndexes(indexesNode: IndexesNode): string[];
    visitCreateIndex(createIndexNode: CreateIndexNode): string[];
    visitDropIndex(dropIndexNode: DropIndexNode): string[];
    visitIfNotExistsIndex(): string[];
    visitCase(caseNode: CaseNode): string[];
    visitOnConflict(onConflictNode: OnConflictNode): string[];
}

/**
 * Config can contain:
 *
 * nullOrder: 'first' | 'last'
 *
 * @param config
 * @constructor
 */
declare class Postgres extends Dialect<{
    nullOrder?: string;
}> {
    constructor(config: {
        nullOrder?: string;
    });
    protected createSubInstance(): Postgres;
    _getParameterValue(value: null | boolean | number | string | any[] | Date | Buffer | Record<string, any>, quoteChar?: string): string | number;
    visitOrderBy(orderByNode: OrderByNode): string[];
}

declare class Sqlite extends Dialect<{
    dateTimeMillis?: boolean;
}> {
    protected hasAddedAColumn: boolean;
    constructor(config: {
        dateTimeMillis?: boolean;
    });
    protected createSubInstance(): Sqlite;
    _getParameterValue(value: null | boolean | number | string | any[] | Date | Buffer | Record<string, any>, quoteChar?: string): string | number;
    visitReplace(replaceNode: ReplaceNode): string[];
    visitDefault(defaultNode: DefaultNode): string[];
    visitDropColumn(dropColumnNode: DropColumnNode): string[];
    visitFunctionCall(functionCallNode: FunctionCallNode): string[];
    visitTruncate(truncateNode: TruncateNode): string[];
    visitRenameColumn(renameColumnNode: RenameColumnNode): string[];
    visitOnDuplicate(onDuplicateNode: OnDuplicateNode): string[];
    visitOnConflict(onConflictNode: OnConflictNode): string[];
    visitReturning(returningNode: ReturningNode): string[];
    visitForUpdate(forUpdateNode: ForUpdateNode): string[];
    visitForShare(forShareNode: ForShareNode): string[];
    visitAddColumn(addColumnNode: AddColumnNode): string[];
    visitIndexes(indexesNode: IndexesNode): string[];
    visitCreateIndex(createIndexNode: CreateIndexNode): string[];
    visitCascade(cascadeNode: CascadeNode): string[];
    visitRestrict(restrictNode: RestrictNode): string[];
    visitBinary(binaryNode: BinaryNode): string[];
    visitOrIgnore(orIgnoreNode: OrIgnoreNode): string[];
}

export { AddColumnNode, AliasMixin, AliasNode, AlterNode, ArrayCallNode, AtNode, BinaryNode, CascadeNode, CaseNode, CastNode, Column, ColumnNode, CreateIndexNode, CreateNode, CreateViewNode, DEFAULT_DIALECT, DefaultNode, DeleteNode, Dialect, DistinctNode, DistinctOnNode, DropColumnNode, DropIndexNode, DropNode, ForShareNode, ForUpdateNode, ForeignKeyNode, FromNode, FunctionCallNode, GroupByNode, HavingNode, IfExistsNode, IfNotExistsNode, InNode, IndexCreationQuery, IndexesNode, InsertNode, IntervalNode, JoinNode, LiteralNode, ModifierNode, Mssql, Mysql, Node, NotInNode, OnConflictNode, OnDuplicateNode, OrIgnoreNode, Oracle, OrderByNode, OrderByValueNode, ParameterNode, PostfixUnaryNode, Postgres, PrefixUnaryNode, Query, RenameColumnNode, RenameNode, ReplaceNode, RestrictNode, ReturningNode, RowCallNode, SelectNode, SliceNode, Sql, Sqlite, SubQuery, Table, TableNode, TableWithColumns, TernaryNode, TruncateNode, UpdateNode, WhereNode, getDialect, registerDialect };
