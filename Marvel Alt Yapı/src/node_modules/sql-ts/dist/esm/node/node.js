'use strict';
import assert from 'assert';
import { TextNode } from '.';
import { DEFAULT_DIALECT, getDialect } from '../dialect';
import { instanceofINodeable } from '../nodeable';
export class Node {
    constructor(type) {
        this.type = type;
        this.nodes = [];
    }
    toNode() {
        return this;
    }
    add(node) {
        assert(node, 'Error while trying to add a non-existant node to a query');
        let newNode;
        if (typeof node === 'string') {
            newNode = new TextNode(node);
        }
        else if (instanceofINodeable(node)) {
            newNode = node.toNode();
        }
        else {
            newNode = node;
        }
        this.nodes.push(newNode);
        return this;
    }
    unshift(node) {
        assert(node, 'Error while trying to add a non-existant node to a query');
        this.nodes.unshift(typeof node === 'string' ? new TextNode(node) : node.toNode());
        return this;
    }
    toQuery(dialect) {
        const DialectClass = determineDialect(this, dialect);
        return initializeDialect(DialectClass, this).getQuery(this);
    }
    toNamedQuery(name, dialect) {
        if (!name || typeof name !== 'string' || name === '') {
            throw new Error('A query name has to be a non-empty String.');
        }
        const query = this.toQuery(dialect);
        return Object.assign(Object.assign({}, query), { name });
    }
    toString(dialect) {
        const DialectClass = determineDialect(this, dialect);
        return initializeDialect(DialectClass, this).getString(this);
    }
    addAll(nodes) {
        for (let i = 0, len = nodes.length; i < len; i++) {
            this.add(nodes[i]);
        }
        return this;
    }
}
// Before the change that introduced parallel dialects, every node could be turned
// into a query. The parallel dialects change made it impossible to change some nodes
// into a query because not all nodes are constructed with the sql instance.
const determineDialect = (query, dialect) => {
    const sql = query.sql || (query.table && query.table.sql);
    let DialectClass;
    if (dialect) {
        // dialect is specified
        DialectClass = getDialect(dialect);
    }
    else if (sql && sql.dialect) {
        // dialect is not specified, use the dialect from the sql instance
        DialectClass = sql.dialect;
    }
    else {
        // dialect is not specified, use the default dialect
        DialectClass = getDialect(DEFAULT_DIALECT);
    }
    return DialectClass;
};
const initializeDialect = (DialectClass, query) => {
    const sql = query.sql || (query.table && query.table.sql);
    const config = sql ? sql.config : {};
    return new DialectClass(config);
};
//# sourceMappingURL=node.js.map