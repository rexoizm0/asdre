import { Column } from './column';
import { ColumnDefinition, TableDefinition } from './configTypes';
import { ColumnNode, DropIndexNode, ForeignKeyNode, JoinNode, Node, OrderByValueNode, Query, SubQuery, TableNode } from './node';
import { INodeable, PartialNodeable } from './nodeable';
import { Sql } from './sql';
export declare type TableWithColumns<T> = Table<T> & {
    [Name in NonNullable<keyof T>]: Column<T[Name]>;
};
export declare class Table<T> implements INodeable {
    get nodes(): Node[];
    static define<Model>(config: TableDefinition): TableWithColumns<Model>;
    columnWhiteList: boolean;
    isTemporary: boolean;
    snakeToCamel: boolean;
    columns: Column<T[keyof T]>[];
    foreignKeys: ForeignKeyNode[];
    table: this;
    sql: Sql;
    engine?: string;
    charset?: string;
    alias?: string;
    initialConfig: TableDefinition;
    private schema?;
    private tableName;
    constructor(config: TableDefinition);
    clone(config?: Partial<TableDefinition>): TableWithColumns<T>;
    createColumn(col: string | ColumnDefinition | Column<unknown>): Column<unknown>;
    addColumn(col: string | ColumnDefinition | Column<unknown>, options?: any): this;
    hasColumn(col: Column<unknown> | string): boolean;
    getColumn(colName: string): Column<T[keyof T]> | null;
    get(colName: string): Column<T[keyof T]> | null;
    getSchema(): string | undefined;
    setSchema(schema: string): void;
    getName(): string;
    star(): Column<unknown>;
    star(options: {
        prefix: string;
    }): ColumnNode[];
    count(alias?: string): ColumnNode;
    select(...args: any[]): Query<T>;
    subQuery<C extends object>(alias?: string): SubQuery<T, C>;
    insert(object: Column<unknown>[] | Column<unknown>): Query<T>;
    insert(object: PartialNodeable<T>[] | PartialNodeable<T>): Query<T>;
    insert(...nodes: Column<unknown>[]): Query<T>;
    replace(object: Column<unknown>[] | Column<unknown>): Query<T>;
    replace(object: PartialNodeable<T>[] | PartialNodeable<T>): Query<T>;
    replace(...nodes: Column<unknown>[]): Query<T>;
    toNode(): TableNode;
    join(other: INodeable): JoinNode;
    leftJoin(other: INodeable): JoinNode;
    joinTo(other: Table<unknown>): JoinNode;
    as(alias: string): TableWithColumns<T>;
    and(...args: Node[]): Query<T>;
    indexes(): IndexQuery;
    alter(): Query<T>;
    create(): Query<T>;
    delete(table: Table<unknown>[] | Table<unknown> | Table<T> | Partial<T>): Query<T>;
    delete(): Query<T>;
    drop(): Query<T>;
    from(table: Table<unknown>[] | Table<unknown> | Table<T> | JoinNode): Query<T>;
    from(...tables: Table<unknown>[]): Query<T>;
    limit(count: unknown): Query<T>;
    offset(count: unknown): Query<T>;
    or(object: Partial<T> | Node | string): Query<T>;
    order(node: INodeable[] | INodeable): Query<T>;
    order(...nodes: INodeable[]): Query<T>;
    truncate(): Query<T>;
    update(object: PartialNodeable<T>): Query<T>;
    where(object: Partial<T> | Node[] | Node | string): Query<T>;
    where(...nodes: Node[]): Query<T>;
}
interface IndexQuery {
    create(indexName?: string): IndexCreationQuery;
    drop(indexName: string): DropIndexNode;
    drop(...columns: Column<unknown>[]): DropIndexNode;
}
export interface IndexCreationQuery extends Node {
    ifNotExists(): IndexCreationQuery;
    unique(): IndexCreationQuery;
    using(name: string): IndexCreationQuery;
    on(...columns: (Column<unknown> | OrderByValueNode)[]): IndexCreationQuery;
    withParser(parserName: string): IndexCreationQuery;
    fulltext(): IndexCreationQuery;
    spatial(): IndexCreationQuery;
}
export {};
