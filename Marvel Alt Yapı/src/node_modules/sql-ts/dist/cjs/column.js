'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Column = void 0;
const tslib_1 = require("tslib");
const extend_1 = tslib_1.__importDefault(require("lodash/extend"));
const node_1 = require("./node");
class Column {
    constructor(config) {
        this.subfields = {};
        this.asArray = false;
        this.name = config.name;
        this.property = config.property;
        this.star = config.star;
        this.table = config.table;
        this.alias = undefined;
        this.isConstant = config.isConstant;
        this.constantValue = config.constantValue;
        this.dataType = config.dataType;
        this.primaryKey = config.primaryKey;
        this.notNull = config.notNull;
        this.defaultValue = config.defaultValue;
        this.references = config.references;
        this.subfieldContainer = config.subfieldContainer;
        this.autoGenerated = config.autoGenerated;
        this.unique = config.unique;
    }
    value(value) {
        const context = contextify(this);
        context._value = value;
        return context;
    }
    getValue() {
        return this._value;
    }
    toNode() {
        // creates a query node from this column
        return new node_1.ColumnNode(contextify(this));
    }
    as(alias) {
        const context = contextify(this);
        context.alias = alias;
        return new node_1.ColumnNode(context);
    }
    asc() {
        return new node_1.OrderByValueNode({
            value: this.toNode()
        });
    }
    desc() {
        return new node_1.OrderByValueNode({
            direction: new node_1.TextNode('DESC'),
            value: this.toNode()
        });
    }
    arrayAgg(alias) {
        const context = contextify(this);
        context.asArray = true;
        context.alias = alias || context.name + 's';
        return new node_1.ColumnNode(context);
    }
    aggregate(alias, aggregator) {
        const context = contextify(this);
        context.aggregator = aggregator.toUpperCase();
        context.alias = alias || context.name + '_' + context.aggregator.toLowerCase();
        return new node_1.ColumnNode(context);
    }
    count(alias) {
        return this.aggregate(alias, 'count');
    }
    min(alias) {
        return this.aggregate(alias, 'min');
    }
    max(alias) {
        return this.aggregate(alias, 'max');
    }
    sum(alias) {
        return this.aggregate(alias, 'sum');
    }
    avg(alias) {
        return this.aggregate(alias, 'avg');
    }
    distinct() {
        const context = contextify(this);
        context.isDistinct = true;
        return new node_1.ColumnNode(context);
    }
    toQuery() {
        return this.toNode().toQuery();
    }
}
exports.Column = Column;
// mix in value expression
extend_1.default(Column.prototype, node_1.valueExpressionMixin());
const contextify = (base) => {
    const context = Object.create(Column.prototype);
    Object.keys(base).forEach((key) => {
        context[key] = base[key];
    });
    return context;
};
//# sourceMappingURL=column.js.map